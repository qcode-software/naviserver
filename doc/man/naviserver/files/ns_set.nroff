'\"
'\" Generated from file 'ns_set\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "ns_set" n 4\&.99\&.19 naviserver "NaviServer Built-in Commands"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
ns_set \- Manipulate sets of key-value pairs
.SH SYNOPSIS
\fBns_set\fR ?\fIarg arg \&.\&.\&.\fR?
.sp
\fBns_set array\fR \fIsetId\fR
.sp
\fBns_set cleanup\fR
.sp
\fBns_set copy\fR \fIsetId\fR
.sp
\fBns_set cput\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
.sp
\fBns_set create\fR ?\fIname\fR? ?\fIkey\fR? ?\fIvalue\fR? \&.\&.\&.
.sp
\fBns_set delete\fR \fIsetId\fR \fIfieldNumber\fR
.sp
\fBns_set delkey\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set find\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set free\fR \fIsetId\fR
.sp
\fBns_set get\fR \fIsetId\fR \fIkey\fR ?\fIdefault\fR?
.sp
\fBns_set icput\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
.sp
\fBns_set idelkey\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set ifind\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set iget\fR \fIsetId\fR \fIkey\fR ?\fIdefault\fR?
.sp
\fBns_set imerge\fR \fIhigh\fR \fIlow\fR
.sp
\fBns_set isnull\fR \fIsetId\fR \fIfieldNumber\fR
.sp
\fBns_set iunique\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set iupdate\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
.sp
\fBns_set key\fR \fIsetId\fR \fIfieldNumber\fR
.sp
\fBns_set list\fR
.sp
\fBns_set merge\fR \fIhigh\fR \fIlow\fR
.sp
\fBns_set move\fR \fIto\fR \fIfrom\fR
.sp
\fBns_set name\fR \fIsetId\fR
.sp
\fBns_set print\fR \fIsetId\fR
.sp
\fBns_set put\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
.sp
\fBns_set size\fR \fIsetId\fR
.sp
\fBns_set split\fR \fIsetId\fR ?\fIsplitChar\fR?
.sp
\fBns_set truncate\fR \fIsetId\fR \fIfieldNumber\fR
.sp
\fBns_set unique\fR \fIsetId\fR \fIkey\fR
.sp
\fBns_set update\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
.sp
\fBns_set value\fR \fIsetId\fR \fIfieldNumber\fR
.sp
.BE
.SH DESCRIPTION
This command is used to manipulate sets of key-value pairs or "fields"\&.
The fields in the set are ordered by number\&.  The field numbers start at
zero and increase by one, up to the total number of fields\&.  An ns_set is
actually a multiset - in other words, the same key can appear multiple times
in the same set\&.  This data structure is particularly useful for things like
HTTP headers which have this same property\&.
The legal options (which may be abbreviated) are:
.SH COMMANDS
.TP
\fBns_set\fR ?\fIarg arg \&.\&.\&.\fR?
.PP
.TP
\fBns_set array\fR \fIsetId\fR
Returns the contents of the setId in a string representation similar
to Tcl's array get format\&.  This is useful for converting an ns_set
to an array or for iterating over the key-value pairs with foreach\&.
Since ns_sets can contain the same key multiple times, converting
an ns_set to an array can result in an array that is not exactly
the same as the original ns_set as keys in an array are unique\&.
.TP
\fBns_set cleanup\fR
Frees all sets in the current interp\&.
This command is autoamtically executed by \fBns_cleanup\fR,
which runs after every request, freeing all sets created via
\fBns_set\fR\&.
.TP
\fBns_set copy\fR \fIsetId\fR
Returns a new set that has the same name and contents as the set referenced
in setId\&.  The new set is automatically freed when
the transaction ends\&.
.TP
\fBns_set cput\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
Appends a new field to the set with key and value, if the field does
not already exist in the set (conditional put)\&.  If the field already
exists in the set, the set is unchanged\&.  Returns the field number of
the new field, or the field number of the existing field if it already
exists in the set\&.
.TP
\fBns_set create\fR ?\fIname\fR? ?\fIkey\fR? ?\fIvalue\fR? \&.\&.\&.
Allocates memory for a new set and returns the setId for the new set\&.
The new set is automatically freed when the transaction ends\&.
.TP
\fBns_set delete\fR \fIsetId\fR \fIfieldNumber\fR
Deletes the field in the set at field number fieldNumber\&.
.TP
\fBns_set delkey\fR \fIsetId\fR \fIkey\fR
Removes the first field in the set whose key is key\&.  Note that there could be
multiple fields in the set with this key; this command only removes the first occurrence\&.
.TP
\fBns_set find\fR \fIsetId\fR \fIkey\fR
Returns the index of the first field in the specified setId whose key matches
the specified key\&.  Indexing starts at zero\&.  If no matching fields are found,
ns_set find returns -1\&.
.TP
\fBns_set free\fR \fIsetId\fR
Frees the specified set\&. Sets are
automatically freed when the transaction ends, but for loops with many iterations
it might be useful to free sets manually\&.
.TP
\fBns_set get\fR \fIsetId\fR \fIkey\fR ?\fIdefault\fR?
Returns the first value associated with key\&.  If key isn't in the set,
the default or an empty string is returned\&.
.TP
\fBns_set icput\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
Case-insensitive counterpart of \fBns_set cput\fR\&.
.TP
\fBns_set idelkey\fR \fIsetId\fR \fIkey\fR
Case-insensitive counterpart of \fBns_set delkey\fR\&.
.TP
\fBns_set ifind\fR \fIsetId\fR \fIkey\fR
Case-insensitive counterpart of \fBns_set find\fR\&.
.TP
\fBns_set iget\fR \fIsetId\fR \fIkey\fR ?\fIdefault\fR?
Case-insensitive counterpart of \fBns_set get\fR\&.
.TP
\fBns_set imerge\fR \fIhigh\fR \fIlow\fR
Merges two sets\&. This is the case insensitive version of
\fBns_set merge\fR\&.
.TP
\fBns_set isnull\fR \fIsetId\fR \fIfieldNumber\fR
Returns 1 if the value of the field specified by fieldNumber is null
and 0 if it is not\&.  Note that an empty string is not the same as a
null\&.  \fBns_set isnull\fR will return 0 if the value is an empty
string\&.
.TP
\fBns_set iunique\fR \fIsetId\fR \fIkey\fR
Case-insensitive counterpart of \fBns_set unique\fR\&.
.TP
\fBns_set iupdate\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
Case-insensitive counterpart of \fBns_set update\fR\&.
.TP
\fBns_set key\fR \fIsetId\fR \fIfieldNumber\fR
Returns the key for the field numbered fieldNumber\&.  This command is useful
when looping through all the key-value pairs in the set in order\&.
.TP
\fBns_set list\fR
Returns the list of all ns_sets\&.
.TP
\fBns_set merge\fR \fIhigh\fR \fIlow\fR
Merges two sets\&.  Any fields in the low set are appended to the high set if a
field with the same key name does not already exist in the high set\&.
.TP
\fBns_set move\fR \fIto\fR \fIfrom\fR
Moves all fields from the from set to the end of the to set, leaving
the from set a valid, empty set\&.
.TP
\fBns_set name\fR \fIsetId\fR
Returns the name of the set\&.  Returns an empty string if no name has been set\&.
.TP
\fBns_set print\fR \fIsetId\fR
Prints the specified set to stderr which should go to the server log\&.  This
is useful for debugging, but \fBns_set array\fR may be more useful in actual code\&.
.TP
\fBns_set put\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
Appends a new field to the set with key and value\&.  Note that the field is
appended so if a previous field has the same key as the new field, the previous
field will be returned by \fBns_set get\fR\&.
The field number of the new field is returned\&.
.TP
\fBns_set size\fR \fIsetId\fR
Returns the number of fields in the set\&.
.TP
\fBns_set split\fR \fIsetId\fR ?\fIsplitChar\fR?
Splits one set into multiple sets based on the splitChar as described below and
returns a Tcl list of IDs for the newly-allocated sets\&.  It assumes that the
keys in the source setId contain a specific character (splitChar) that can be used
to separate the name of a new set and the key in the new set\&.  The default splitChar is a period "\&."\&.
.TP
\fBns_set truncate\fR \fIsetId\fR \fIfieldNumber\fR
Removes any fields with index fieldNumber or greater and frees any memory allocated for them\&.
.TP
\fBns_set unique\fR \fIsetId\fR \fIkey\fR
Returns 1 if the specified key is unique in the specified set and 0 if
it is not\&.  For example, a web browser could send multiple "Accept:"
headers which would end up in the header set for the connection\&.
\fBns_set unique\fR would return 0 for the "Accept:" key, because there
are multiple fields with the key "Accept:"\&.  The test for uniqueness
is performed case-sensitively\&.
.TP
\fBns_set update\fR \fIsetId\fR \fIkey\fR \fIvalue\fR
Updates the first field in the specified set whose key is key and replaces its value
with value\&.  This is equivalent to \fBns_set delkey\fR followed by
\fBns_set put\fR if there is
only one field with the key of key\&.
.TP
\fBns_set value\fR \fIsetId\fR \fIfieldNumber\fR
Returns the value of the set at field number fieldNumber\&.  This command is useful
when looping through all the key-value pairs in the set\&.
.PP
.SH EXAMPLES
.CS


   % set mySet [ns_set create mySetName a b c d e f A Joe B John C Jeff]
   d0

.CE
.CS


   % ns_set size $mySet
   6

.CE
.CS


   % ns_set name $mySet
   mySetName

.CE
.CS


   % ns_set array $mySet
   a b c d e f A Joe B John C Jeff

.CE
.CS


   % ns_set get $mySet A
   Joe

.CE
.CS


   % ns_set iget $mySet a
   b

.CE
.CS


   % ns_set unique $mySet a
   1

.CE
.CS


   % ns_set iunique $mySet a
   0

.CE
.CS


   % ns_set truncate $mySet 3

   % ns_set print $mySet
   mySetName:
           a = b
           c = d
           e = f

.CE
.CS


   % ns_set update $mySet c "Hello World!"
   2

.CE
.CS


   % ns_set print $mySet
   mySetName:
           a = b
           e = f
           c = Hello World!

.CE
.CS


   % ns_set find $mySet c
   2

.CE
.CS


   % ns_set find $mySet nokey
   -1

.CE
.CS


   % ns_set delete $mySet 0

.CE
.CS


   % ns_set array $mySet
   e f c {Hello World!}

.CE
.PP
.CS


   % set anotherSet [ns_set create]
   d1

.CE
.CS


   % ns_set list
   d0 d1

.CE
.CS


   % ns_set put $anotherSet dog\&.food "Yummy dog food!"
   0

.CE
.CS


   % ns_set put $anotherSet cat\&.food "Yummy cat food!"
   1

.CE
.CS


   % ns_set print $anotherSet
           dog\&.food = Yummy dog food!
           cat\&.food = Yummy cat food!

.CE
.CS


   % set newSets [ns_set split $anotherSet]
   d2 d3

.CE
.PP
.CS


   % foreach s $newSets { ns_set print $s }
   dog:
           food = Yummy dog food!
   cat:
           food = Yummy cat food!

.CE
.CS


   % ns_set key $anotherSet 0
   dog\&.food

.CE
.CS


   % ns_set value $anotherSet 1
   Yummy cat food!

.CE
.CS


   % ns_set move $mySet $anotherSet
   d0

.CE
.CS


   % ns_set array $mySet
   e f c {Hello World!} dog\&.food {Yummy dog food!} cat\&.food {Yummy cat food!}

.CE
.CS


   % ns_set array $anotherSet

.CE
.CS


   % set thirdSet [ns_set new]
   d4

.CE
.CS


   % ns_set move $thirdSet $mySet
   d4

.CE
.CS


   % ns_set array $thirdSet
   e f c {Hello World!} dog\&.food {Yummy dog food!} cat\&.food {Yummy cat food!}

.CE
.CS


   % array set testArray [ns_set array $thirdSet]

.CE
.CS


   to run through an ns_set
   for {set i 0} {$i < [ns_set size $myset]} {incr i} {
       set key [ns_set key $myset $i]
       set value [ns_set value $myset $i]
   }

.CE
.SH NOTES
.PP
The ns_set command currently reports that it accepts two additional subcommands,
idelete and purge\&.  These are both noops (idelete may be a mistake as delete is already case-irrelevant)\&.
.PP
NULL values, distinct from the empty string, are useful when representing a
database row as an ns_set\&.  Currently, it is difficult to get a NULL value
in an ns_set through the Tcl API\&.  You may get a NULL value in the set created
by ns_parsequery or by omitting the last value when seeding the ns_set in the
create/new subcommand, etc\&.  It is possible to create NULL-valued fields through the C API\&.
.PP
ns_set is intended for relatively small amounts of data\&.  (Keys are found by
a linear search through the whole underlying C array\&.)  If you stuff very large
amounts of data into an ns_set, performance will be very poor - use a
Tcl Array or a Tcl dict instead\&.
.SH "SEE ALSO"
ns_cleanup, ns_findset, ns_ictl
.SH KEYWORDS
data structure, global built-in, ns_set