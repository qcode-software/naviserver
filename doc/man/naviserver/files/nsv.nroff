'\"
'\" Generated from file 'nsv\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "nsv" n 4\&.99\&.23 naviserver "NaviServer Built-in Commands"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
nsv \- NaviServer nsv Commands
.SH SYNOPSIS
\fBnsv_array get\fR \fIarray\fR ?\fIpattern\fR?
.sp
\fBnsv_array set\fR \fIarray\fR \fIvalue-list\fR
.sp
\fBnsv_array reset\fR \fIarray\fR \fIvalue-list\fR
.sp
\fBnsv_array exists\fR \fIarray\fR
.sp
\fBnsv_array size\fR \fIarray\fR
.sp
\fBnsv_array names\fR \fIarray\fR ?\fIpattern\fR?
.sp
\fBnsv_bucket\fR ?\fIbucket-nr\fR?
.sp
\fBnsv_dict append\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIvalue \&.\&.\&.\fR?
.sp
\fBnsv_dict exists\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR?
.sp
\fBnsv_dict get\fR ?-varname \fIvarname\fR? \fIarray\fR \fIkey\fR ?\fIdictkey \&.\&.\&.\fR?
.sp
\fBnsv_dict getdef\fR ?-varname \fIvarname\fR? \fIarray\fR \fIkey\fR ?\fIdictkey \&.\&.\&.\fR? \fIdefault\fR
.sp
\fBnsv_dict incr\fR \fIarray\fR \fIkey\fR ?\fIincrement\fR?
.sp
\fBnsv_dict keys\fR \fIarray\fR \fIkey\fR ?\fIpattern\fR?
.sp
\fBnsv_dict lappend\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIvalue \&.\&.\&.\fR?
.sp
\fBnsv_dict set\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR? \fIvalue\fR
.sp
\fBnsv_dict size\fR \fIarray\fR \fIkey\fR
.sp
\fBnsv_dict unset\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR?
.sp
\fBnsv_exists\fR \fIarray\fR \fIkey\fR
.sp
\fBnsv_get\fR \fIarray\fR \fIkey\fR ?\fIvarName\fR?
.sp
\fBnsv_incr\fR \fIarrayName\fR \fIkey\fR ?\fIincrement\fR?
.sp
\fBnsv_append\fR \fIarray\fR \fIkey\fR \fIvalue\fR ?\fIvalue \&.\&.\&.\fR?
.sp
\fBnsv_lappend\fR \fIarray\fR \fIkey\fR \fIvalue\fR ?\fIvalue \&.\&.\&.\fR?
.sp
\fBnsv_names\fR ?\fIpattern\fR?
.sp
\fBnsv_set\fR ?\fB-default\fR? ?\fB-reset\fR? \fIarray\fR \fIkey\fR ?\fIvalue\fR?
.sp
\fBnsv_unset\fR ?\fB-nocomplain\fR? ?--? \fIarray\fR ?\fIkey\fR?
.sp
.BE
.SH DESCRIPTION
The nsv commands provide a high performance data sharing mechanism\&.
This facility is much flexible alternative to the obsolete ns_share
command\&.  The model uses an array syntax and includes more features\&.
In addition, lock contention is managed in a much more scalable
way--something that is not possible with the obsolete ns_share
facility\&.
.SH COMMANDS
.TP
\fBnsv_array get\fR \fIarray\fR ?\fIpattern\fR?
.TP
\fBnsv_array set\fR \fIarray\fR \fIvalue-list\fR
.TP
\fBnsv_array reset\fR \fIarray\fR \fIvalue-list\fR
.TP
\fBnsv_array exists\fR \fIarray\fR
.TP
\fBnsv_array size\fR \fIarray\fR
.TP
\fBnsv_array names\fR \fIarray\fR ?\fIpattern\fR?
Commands for the most part mirror the corresponding Tcl command for
ordinary variables\&.
.CS


 % nsv_array set shared_array { key1 value1 key2 value2 }

 % nsv_array get shared_array
 key1 value1 key2 value2

 % nsv_array reset shared_array { key3 value3 }

 % nsv_array exists shared_array
 1

 % nsv_array size shared_array
 1

 % nsv_array names shared_array
 key3

 % nsv_array set shared_array [array get tmp_shared_array]
 % array set tmp_shared_array [nsv_array get shared_array]
 % nsv_array reset shared_array [array get tmp_shared_array]

.CE
.TP
\fBnsv_bucket\fR ?\fIbucket-nr\fR?
Return a list of all the array names with lock counts from the specified
bucket\&. If no bucket-nr is specified, return a list of all arrays from
all buckets\&.  This command is mainly for performance tuning\&. When e\&.g\&.
the number of locks for a certain bucket is high one can use this
command to determine the arrays with their usages from this bucket\&.
.CS


 set buckets ""
 set count -1
 foreach b [nsv_bucket] {
    append buckets "[incr count]: " [lsort -integer -index 1 -decreasing $b] \\n
 }
 ns_log notice $buckets

.CE
.TP
\fBnsv_dict append\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIvalue \&.\&.\&.\fR?
.TP
\fBnsv_dict exists\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR?
.TP
\fBnsv_dict get\fR ?-varname \fIvarname\fR? \fIarray\fR \fIkey\fR ?\fIdictkey \&.\&.\&.\fR?
.TP
\fBnsv_dict getdef\fR ?-varname \fIvarname\fR? \fIarray\fR \fIkey\fR ?\fIdictkey \&.\&.\&.\fR? \fIdefault\fR
.TP
\fBnsv_dict incr\fR \fIarray\fR \fIkey\fR ?\fIincrement\fR?
.TP
\fBnsv_dict keys\fR \fIarray\fR \fIkey\fR ?\fIpattern\fR?
.TP
\fBnsv_dict lappend\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIvalue \&.\&.\&.\fR?
.TP
\fBnsv_dict set\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR? \fIvalue\fR
.TP
\fBnsv_dict size\fR \fIarray\fR \fIkey\fR
.TP
\fBnsv_dict unset\fR \fIarray\fR \fIkey\fR \fIdictkey\fR ?\fIdictkey \&.\&.\&.\fR?
Implementation of the Tcl \fIdict\fR command for shared variables\&.
The commands work similar as \fBnsv_set\fR and \fBnsv_get\fR,
except that the value of these commands are structure values in form
of dicts\&.
.sp
The main difference to plain Tcl is the option
?-varname \fIvarname\fR?\&.
When this option is provided, the function returns 0 or 1 depending
on success and returns in the success case the value in the provided
variable\&. When the varname option is provided, the behavior is
similar to the optional last argument in \fBnsv_get\fR or
\fBns_cache_get\fR
The option ?-varname \fIvarname\fR? has the adavantage
to test and get the value with a single locked command\&. This avoids
race conditions and reduces the number of locks for the application\&.
.CS


 % nsv_dict set personnel 4711 name gustaf
 name gustaf

 % nsv_dict set personnel 4711 sex m
 name gustaf sex m

 % nsv_dict get personnel 4711 name
 gustaf

 % nsv_dict get personnel 4711
 name gustaf sex m

.CE
.TP
\fBnsv_exists\fR \fIarray\fR \fIkey\fR
Test whether a key exists in the nsv array\&.
.CS


 % nsv_exists shared_array key1
 1
 % nsv_exists shared_array key2
 0

.CE
.TP
\fBnsv_get\fR \fIarray\fR \fIkey\fR ?\fIvarName\fR?
Get the value for the key from the nsv array\&.  If the optional
\fIvarName\fR is provided, the function returns on success 1 and on
failure 0\&. On success, it binds the variable \fIvarName\fR\&. If the
variable name is not provided, it returns on success the value and
raises on failure an error (similar to \fBns_cache_get\fR)\&.
With the optional variable name, this function allows an atomic
check for existence followed by a get operation\&.
.CS


 % nsv_get shared_array key1
 value1

.CE
.TP
\fBnsv_incr\fR \fIarrayName\fR \fIkey\fR ?\fIincrement\fR?
If increment is supplied then its value (which must be an integer) is added to the
value of the element key; otherwise 1 is added to the value of the element key\&.
Unlike the Tcl equivalent if key does not exists it is created\&. Returns the new value
of the element specified by key\&. Internally interlocked so it is thread safe, no mutex required\&.
.CS


 % nsv_incr shared_array foo
 1
 % nsv_incr shared_array foo -1
 0

.CE
.TP
\fBnsv_append\fR \fIarray\fR \fIkey\fR \fIvalue\fR ?\fIvalue \&.\&.\&.\fR?
Append all of the value arguments to the current value of variable key in the array\&.
If key doesn't exist, it is given a value equal to the concatenation of all the value arguments
.CS


 % nsv_append shared_array key1 foo
 value1foo

.CE
.TP
\fBnsv_lappend\fR \fIarray\fR \fIkey\fR \fIvalue\fR ?\fIvalue \&.\&.\&.\fR?
Append all of the value arguments as list elements to variable key in the array\&.
If key doesn't exist, it is created as a list with elements given by the value arguments
.CS


 % nsv_lappend shared_array key1 value2
 value1 value2

.CE
.TP
\fBnsv_names\fR ?\fIpattern\fR?
Return a list of all the nsvs in use, optionally only those matching pattern\&. If no
matching nsvs are in use returns the empty string\&.
.CS


 % nsv_names
 shared_array

.CE
.TP
\fBnsv_set\fR ?\fB-default\fR? ?\fB-reset\fR? \fIarray\fR \fIkey\fR ?\fIvalue\fR?
Set the value for a key in an nsv array\&. Returns the value the key is
set to\&. The various options are especially useful to implement atomic
operations\&.
.RS
.TP
\fB-default\fR
When this flag is specified nothing is changed in case
the key \fIkey\fR of \fIarray\fR has already an
value\&. Otherwise it sets the value\&.
This operation is similar to SETNX in REDIS (set if no exists)\&.
.TP
\fB-reset\fR
When this flag is specified and a \fIvalue\fR is given, the command
resets the value for \fIkey\fR and returns the \fIold\fR value\&.
This operation is similar to GETSET in REDIS (get the old value and
set it new)\&.
.sp
When this flag is specified but no \fIvalue\fR is
provided, the command returns the value for \fIkey\fR and unsets resets it\&.
.RE
.CS


 % nsv_set shared_array key1 value1
 value1

.CE
.TP
\fBnsv_unset\fR ?\fB-nocomplain\fR? ?--? \fIarray\fR ?\fIkey\fR?
Unset an array or a single key from an array\&. If successful returns an
empty string\&. When \fB-nocomplain\fR is specified the command does not
complain when the specified array or key does not exist\&.
.CS


 % nsv_unset shared_array key1
 % nsv_unset shared_array

.CE
.PP
.SH "MIGRATING FROM NS_SHARE"
Migrating from ns_share is straightforward\&.  If your init\&.tcl included commands such as:
.CS


 ns_share myshare
 set myshare(lock) [ns_mutex create]

.CE
use instead:
.CS


 nsv_set myshare lock [ns_mutex create]

.CE
In your procedures, instead of:
.CS


 proc myproc {} {
     ns_share myshare
     ns_mutex lock $myshare(lock)
     \&.\&.\&.
 }

.CE
use:
.CS


 proc myproc {} {
     ns_mutex lock [nsv_get myshare lock]
     \&.\&.\&.
 }

.CE
and within an ADP page, instead of:
.CS


 <%
  ns_share myshare
  ns_puts $myshare(key1)
 %>

 <%=$myshare(key2)%>

.CE
use:
.CS


 <%
 ns_puts [nsv_get myshare key1]
 %>

 <%=[nsv_get myshare key2]%>

.CE
Notice that, unlike ns_share, no command is required to define the
shared array\&.  The first attempt at setting the variable through any
means will automatically create the array\&.  Also notice that only arrays
are supported\&.  However, to migrate from ns_share you can simply package
up all existing ns_share scalars into a single array with a short name,
perhaps just "\&."\&. For example, if you had:
.CS


 ns_share mylock myfile
 set myfile /tmp/some\&.file
 set mylock [ns_mutex create]

.CE
you can use:
.CS


 nsv_set \&. myfile /tmp/some\&.file
 nsv_set \&. mylock [ns_mutex create]

.CE
.SH "MULTITHREADING FEATURES"
One advantages of nsv is built in interlocking for thread safety\&.
For example, consider a case of a "increment-by-one" unique id system\&.
Here's the ns_share solution:
.CS


 ns_share ids
 set ids(lock) [ns_mutex create]
 set ids(next) 0

 proc nextid {} {
     ns_share ids
     ns_mutex lock $ids(lock)
     set next [incr ids(next)]
     ns_mutex unlock $ids(lock)
     return $next
 }

.CE
and here's an nsv solution:
.CS


 nsv_set ids next 0

 proc nextid {} {
     return [nsv_incr ids next]
 }

.CE
Note that the nsv solution does not need a mutex as the nsv_incr command
is internally interlocked\&.
.SH "COMPATIBILITY WITH TCL ARRAYS"
Another useful feature of nsv is the nsv_array command which works much
like the Tcl array command\&.  This can be used to import and export values
from ordinary Tcl arrays\&.  For example, to copy from Tcl use:
.CS


 nsv_array set meta [array get tmpmeta]

.CE
and to copy to Tcl use:
.CS


 array set metacopy [nsv_array get meta]

.CE
As with all other nsv command, nsv_array is atomic and no explicit
locking is required\&.  This feature can be used to construct a new nsv
array by first filling up an ordinary temporary Tcl array via some time
consuming process and then swapping it into place as above\&.  While the
new temporary array is being constructed, other threads can access the
old array without delay or inconsistent data\&.  You can even reset a
complete nsv array in one step with "reset"\&.  For example, instead of:
.CS


 ns_share lock meta
 set lock [ns_mutex create]
 ns_mutex lock $lock
 unset meta
 array set meta [array get tmpmeta]
 ns_mutex unlock $lock

.CE
you can simply use:
.CS


 nsv_array reset meta [array get tmpmeta]

.CE
The reset option will flush and then reset all values atomically,
eliminating the need for the explicit lock\&.
.SH CONFIGURATION
All accesses to shared variables are protected by a mutex\&. Attention
should be taken for array operations which have to iterate over
many shared variables to return the result, since this will lead
to reduced scalability due too long lasting locks\&.
.SS "NUMBER OF BUCKETS"
The nsv system uses a common multithreading technique to reduce the
potential for lock contention which is to split the locks to achieve
finer grained locking\&.  This technique groups arrays randomly into
buckets and only the arrays within a particular bucket share a lock\&.
The number of buckets to be used can be configured by setting the
\fBnsvbuckets\fR Tcl parameters, e\&.g\&.:
.CS


 ns_section  ns/server/${server}/tcl {
   # Number of buckets in Tcl hash table for nsv vars
   ns_param nsvbuckets 16
 }

.CE
The default value for \fInsvbuckets\fR is 8 which should be
reasonable for most applications\&.  Note that you can monitor the lock
contention by viewing the results of "ns_info locks" command after the
server has been running for some time\&.  The nsv locks all have names
of the form "nsv:##"\&.  If you find many lock attempts which did not
succeeded immediately, try increasing \fInsvbuckets\fR\&.
.SS "MUTEX LOCKS VS\&. RWLOCKS"
An RWLock allows concurrent read access and a single writer, while a
mutex locks allows only a single reader or a single writer at the same
time\&. The RWLock has more overhead to support concurrency, but in case
there are more read than write operations, RWLocks are better (but
this might be different by the support for RWLocks)\&. In general, for
Web server applications (like e\&.g\&. OpenACS), most nsv variables have a
write ratio of way below 1%\&. However, applications might be different,
so NaviServer allows the specify in the configuration file, whether
mutex locks or rwlocks might be used\&.
.CS


 ns_section  ns/server/${server}/tcl {
   ns_param nsvrwlocks false   ;# default true
 }

.CE
.SH "SEE ALSO"
ns_cache, ns_set, ns_urlspace, nsd
.SH KEYWORDS
configuration, data structure, mutex, nsv, server built-in, shared, variables
