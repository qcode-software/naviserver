'\"
'\" Generated from file 'ns_proxy\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "ns_proxy" n 4\&.99\&.19 nsproxy "NaviServer Module Commands"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
ns_proxy \- Execute Tcl scripts in an external process
.SH SYNOPSIS
\fBns_proxy active\fR \fIpool\fR ?\fIhandle\fR?
.sp
\fBns_proxy cleanup\fR
.sp
\fBns_proxy clear\fR \fIpool\fR ?\fIhandle\fR?
.sp
\fBns_proxy configure\fR \fIpool\fR ?-key val -key val\&.\&.\&.?
.sp
\fBns_proxy eval\fR \fIhandle\fR \fIscript\fR ?\fItimeout\fR?
.sp
\fBns_proxy free\fR \fIpool\fR
.sp
\fBns_proxy get\fR \fIpool\fR ?\fB-handles \fIn\fR\fR? ?\fB-timeout \fIms\fR\fR?
.sp
\fBns_proxy handles\fR
.sp
\fBns_proxy ping\fR \fIhandle\fR
.sp
\fBns_proxy pools\fR
.sp
\fBns_proxy put\fR \fIhandle\fR
.sp
\fBns_proxy recv\fR \fIhandle\fR
.sp
\fBns_proxy release\fR \fIhandle\fR
.sp
\fBns_proxy send\fR \fIhandle\fR \fIscript\fR
.sp
\fBns_proxy stats\fR \fIpool\fR
.sp
\fBns_proxy stop\fR \fIpool\fR ?\fIhandle\fR?
.sp
\fBns_proxy wait\fR \fIhandle\fR ?\fItimeout\fR?
.sp
.BE
.SH DESCRIPTION
\fBns_proxy\fR provides a simple, robust proxy mechanism to evaluate
Tcl scripts in a separate, pipe-connected process\&. This approach
can be useful both to isolate potentially thread-unsafe code outside
the address space of a multithreaded process such as NaviServer or
to enable separation and timeout of potentially misbehaving, long
running scripts\&.
.PP
The command is provided by the \fInsproxy\fR dynamic library which
can be loaded into an interpreter via the Tcl \fIload\fR command,
for example:
.CS


load "\fI/usr/local/lib/libnsproxy\&.so\fR"
\fBns_proxy\fR \&.\&.\&.

.CE
.PP
It is also possible to load the library into all interpreters of
a NaviServer virtual server by specifying an \fInsproxy\&.so\fR entry
in the server's module config entry, for example:
.CS


\fBns_section\fR "ns/server/server1/modules"
\fBns_param\fR nsproxy  nsproxy\&.so

.CE
.PP
When loaded, the library adds the single \fBns_proxy\fR command with
takes multiple options as described below\&. Proxies (i\&.e\&. slave
processes) are normally created on demand when requested and connected
to the parent process via pipes used to send scripts and receive response\&.
Proxies remain active until the parent process exits, effectively closing
all pipes to the slave processes, or when their idle timer expires, depending
on the setup of the \fIpool\fR (see \fBns_proxy configure\fR)\&.
.PP
Proxies are obtained from their corresponding \fIpool\fR by means of the
\fBns_proxy get\fR command\&. Only the thread that obtained the proxy can use
it to communicate with the slave process\&. In order to allow other threads to
use the same proxy, the thread must return (via the \fBns_proxy put\fR or
\fBns_proxy cleanup\fR commands) the proxy back to it's/theirs corresponding
pool/s\&. One thread can obtain one or a bunch of proxies from a pool in one step\&.
It cannot, however, repeatedly obtain proxy by proxy in a loop, as this may
lead to difficult-to-trace deadlock situation (see \fBns_proxy get\fR command)\&.
.SH COMMANDS
.TP
\fBns_proxy active\fR \fIpool\fR ?\fIhandle\fR?
Returns a list of currently evaluating scripts in proxies for
the given \fIpool\fR\&.
.sp
The output is one or more lists, depending on the optional
?handle? argument\&. If the optional argument is
given, only the status of the proxy for the given handle is
returned and the result is a one-element list\&. Otherwise, statuses of
all active proxies for the given \fIpool\fR are returned and the
result is a list of two or more elements\&.
.sp
Each element itself is a list which includes several keys: \fIhandle\fR,
\fIslave\fR, \fIstart\fR, \fIscript\fR and their associated values\&.
This format is suitable for filling in a Tcl array with the
\fBarray set\fR Tcl command\&.
The \fIhandle\fR key contains the handle of the proxy\&.
The \fIslave\fR key contains the process-id of the slave process\&.
The \fIstart\fR key contains the timestamp with the absolute time
when this proxy has been activated\&. The timestamp is in format that
\fBns_time\fR command understands\&.
.sp
The \fIscript\fR contains the script passed to the proxy for execution\&.
It is also possible to view the currently evaluating scripts with the
Unix \fIps\fR command as the proxy slave process re-writes it's command
argument space with the request script before evaluation and clears it
after sending the result\&.
.TP
\fBns_proxy cleanup\fR
Releases any handles from any pools currently owned by a thread\&.
.sp
This command is intended to be used as part of a garbage collection
step\&.Calling this command within NaviServer is not necessary as the
module registers a trace to release all handles via the
\fBns_ictl trace deallocate\fR facility when interpreters are deallocated
after some transaction, for example, at the end of a connection\&.
.TP
\fBns_proxy clear\fR \fIpool\fR ?\fIhandle\fR?
Stop all slave processes attached to free proxies for the given \fIpool\fR\&.
If the optional \fIhandle\fR is given, it stops the process only for
that handle\&.
.TP
\fBns_proxy configure\fR \fIpool\fR ?-key val -key val\&.\&.\&.?
Configures options for the \fIpool\fR\&. The \fIpool\fR is created with
default options if it does not already exist\&. Default options for the
\fIpool\fR are taken from the NaviServer configuration file under the
section "ns/server/$servername/module/nsproxy"\&. In case
the library is loaded in plain Tcl shell, default configuration options
are fixed and cannot be changed w/o recompiling the code\&.
Configurable options include:
.RS
.TP
\fB-init\fR \fIscript\fR
Specifies a script to evaluate when proxies are started\&.  This can
be used to load additional libraries and/or source script files\&.
The default is no script\&.
.TP
\fB-reinit\fR \fIscript\fR
Specifies a script to evaluate after being allocated and before
being returned to the caller\&. This can be used to re-initialize
the slave state\&. The default is no script\&.
.TP
\fB-maxslaves\fR \fIn\fR
Sets the maximum number of proxy slave processes\&. Requests for
proxies beyond the maximum will result in requesting threads
waiting for existing proxies to be available instead of creating
new proxy processes\&. Setting this value to 0 disables the pool,
causing all subsequent allocation requests to fail immediately
(currently allocated proxies, if any, remain valid)\&.
.TP
\fB-maxruns\fR \fIn\fR
Sets the maximum number of activation of the proxy slave process\&.
When the limit it reached, the slave process is automatically restarted\&.
.TP
\fB-exec\fR \fIprogram\fR
Specifies the filename of a slave proxy program\&.  The default is
\fInsproxy\fR in the \fIbin\fR subdirectory of the NaviServer
runtime\&. It is possible to create a custom program and enter the
proxy event loop with the \fINs_ProxyMain\fR application startup
routine; see the source code for details\&.
.TP
\fB-gettimeout\fR \fIms\fR
Specifies the maximum time to wait to allocate handles from the pool\&.
The default is 5000 milliseconds\&.
.TP
\fB-evaltimeout\fR \fIms\fR
Specifies the maximum time to wait for a script to be evaluated in
a proxy\&. This parameter can be overridden on a per-call basis with
the optional ?timeout? parameter to \fBns_proxy eval\fR\&.
The default is 0 milliseconds i\&.e\&. infinite\&.
.TP
\fB-sendtimeout\fR \fIms\fR
.TP
\fB-recvtimeout\fR \fIms\fR
Specifies the maximum time to wait to send a script and receive a
result from a proxy\&.  The default is 1000 milliseconds which assumes
minimal delay sending and receiving reasonably sized scripts and
results over the connecting pipe\&.
.TP
\fB-waittimeout\fR \fIms\fR
Specifies the maximum time to wait for a proxy to exit\&. The wait
is performed in a dedicated reaper thread\&. The reaper will close
the connection pipe and wait the given timeout\&. If the timeout is
exceeded, the reaper will send a SIGTERM signal and finally a SIGKILL
signal to ensure the process eventually exits\&. The default is 100
milliseconds which should be ample time for a graceful exit unless
the process is hung executing a very long, misbehaving script,
resulting in a more disruptive SIGTERM or SIGKILL\&.
.TP
\fB-idletimeout\fR \fIms\fR
Specifies the maximum time for an idle slave process to live\&.
Minimum value is 5000 milliseconds\&. After expiry of the idle
timeout, the reaper thread will close the connection pipe and
wait \fB-waittimeout\fR milliseconds for the process to die\&.
If the timeout is exceeded, the reaper will send a SIGTERM
signal and finally a SIGKILL signal (waiting \fB-waittimeout\fR
milliseconds in between) to ensure the process eventually exits\&.
.TP
\fB-env\fR \fIsetname\fR
Initializes the slave's process environment with keys/values
passed in the named NaviServer set (see command \fBns_set\fR)\&.
.sp
Slave processes whose handles are already attached to some Tcl
interps by the means of the \fBns_proxy get\fR command) are not
expired automatically\&. The idle timer starts to count at the moment
their handles are put back to the pool by the \fBns_proxy put\fR
or \fBns_proxy cleanup\fR command\&.
.RE
.TP
\fBns_proxy eval\fR \fIhandle\fR \fIscript\fR ?\fItimeout\fR?
Evaluates \fIscript\fR in the proxy specified by \fIhandle\fR\&.
The optional ?timeout? argument specifies a maximum number of
milliseconds to wait for the command to complete before raising an
error (see ERROR HANDLING below for details on handling errors)\&.
.sp
Alternatively, the \fIhandle\fR itself may be used as Tcl command like
in the example below:
.CS


set handle [\fBns_proxy\fR get mypool]
$handle "short_running_proc"
$handle "long_running_proc" 20000

.CE
.TP
\fBns_proxy free\fR \fIpool\fR
Returns a list of all free proxies for the given \fIpool\fR\&. Free
proxies are those which are left in the pool queue waiting to
be used by the \fBns_proxy get\fR command\&. Some proxies may have
an active slave process attached, some not\&. If a slave process is
not attached to the free proxy, a new one will be created as soon
as the proxy is requested by some thread\&.
.TP
\fBns_proxy get\fR \fIpool\fR ?\fB-handles \fIn\fR\fR? ?\fB-timeout \fIms\fR\fR?
Returns one or more handles to proxies from the specified \fIpool\fR\&.
.sp
The \fIpool\fR will be created with default options if it does not
already exist\&. The optional \fB-handle\fR can be used to
specify the number of handles to allocate, the default being 1\&.
.sp
The optional ?-timeout ms? arguments specifies the maximum
amount of time in milliseconds to wait for the handles to become
available before raising an error (see ERROR HANDLING below
for details on handling errors)\&.
.sp
Requesting more than one handle in a single call (if more than one
handle is required) is necessary as it is an error to request
handles from a \fIpool\fR from which handles are already owned by
the thread\&. This restriction is implemented to avoid possible
deadlock conditions\&.
.sp
The handle returned by this command can be used as a scalar value for
other \fBns_proxy\fR commands, or it can be used as Tcl command itself
(see \fBns_proxy eval\fR for more information)\&.
.sp
The proxy \fIpool\fR naming convention allows proxy slaves to be started
under different Unix UID/GID then the server itself\&. For that to work,
the server must be running under root user (UID = 0)\&. The naming
convention is simple: pool_name:<optional_user_id>:<optional_group_id>\&.
.sp
For example, to start the proxy for the pool "mypool" with user UID
of 100 the pool name can be constructed as: "mypool:100"\&. To start the
proxy with UID of 100 and group GID of 200: "mypool:100:200"\&. Instead
of numeric values user/group names can also be used\&.
.sp
Beware: if the main server is not running under privileged root user,
the startup of the proxy under some alternative UID/GID may/will fail\&.
.TP
\fBns_proxy handles\fR
Returns list of all proxies allocated for the current interpreter\&.
.TP
\fBns_proxy ping\fR \fIhandle\fR
This command sends a null request to the proxy specified by the
\fIhandle\fR argument\&. The proxy will be verified alive and restarted
if necessary\&.  This command is not normally required as the
\fBns_proxy eval\fR command will also verify and restart proxies
as needed\&.
.TP
\fBns_proxy pools\fR
Returns a list of all currently defined proxy pools\&.
.TP
\fBns_proxy put\fR \fIhandle\fR
This command is alternate name for \fBns_proxy release\fR\&.
.TP
\fBns_proxy recv\fR \fIhandle\fR
Reads result from the script from the proxy specified by \fIhandle\fR
(see ERROR HANDLING below for details on handling errors)\&.
.TP
\fBns_proxy release\fR \fIhandle\fR
Return the proxy \fIhandle\fR to the pool\&. All handles owned by a
thread to the corresponding pool must be returned before any handles
can be allocated again\&. Within the server, a call to this routine is
recommended for clarity but not strictly necessary\&. NaviServer
installs a trace to release all handles at the end of every connection
during interpreter deallocation\&.
.TP
\fBns_proxy send\fR \fIhandle\fR \fIscript\fR
Sends \fIscript\fR to the proxy specified by \fIhandle\fR\&.
(see ERROR HANDLING below for details on handling errors)\&.
.TP
\fBns_proxy stats\fR \fIpool\fR
Provide usage statistics in form of a dict from the specified pool\&.
.TP
\fBns_proxy stop\fR \fIpool\fR ?\fIhandle\fR?
Stop all slave processes attached to running proxies for the given \fIpool\fR\&.
If the optional \fIhandle\fR is given, it stops the process only for
that handle\&.
.TP
\fBns_proxy wait\fR \fIhandle\fR ?\fItimeout\fR?
Waits for results from the proxy specified by \fIhandle\fR\&.
The optional \fItimeout\fR argument specifies a maximum number of
milliseconds to wait for the command to complete before raising an
error (see ERROR HANDLING below for details on handling errors)\&.
.PP
.SH "ERROR HANDLING"
Errors generated by a script evaluated in a proxy interpreter are
completely returned to the calling interpreter, including mapping
the \fIerrorInfo\fR and \fIerrorCode\fR global variables from the
proxy to the parent and raising a Tcl exception\&. This approach makes
ns_proxy evaluations look very similar to the Tcl \fBeval\fR
command\&.
.PP
Errors raised by a failure to communicate with the proxy process
due to a timeout or unexpected process exit are also communicated
back to the parent interpreter as Tcl exceptions\&.  To distinguish
between these cases, communication related errors set the
\fIerrorCode\fR global variable with the first element
\fINSPROXY\fR\&.  The second element is one of the following:
.TP
EDeadlock
The interpreter attempted to allocate handles from a pool from which
it already owns one or more handles\&.
.TP
EExec
The slave program specified by the \fB-exec program\fR option could
not be started\&.
.TP
EImport
The response from the proxy was invalid\&.
.TP
ERecv
There was an error receiving the result from the slave process\&.
.TP
ESend
There was an error sending the script to the slave process\&.
.TP
EGetTimeout
Timeout while waiting to get a proxy handle from the pool\&.
.TP
EEvalTimeout
Timeout while waiting for the response from the proxy process after
sending the command for evaluation\&.
.TP
ERange
Requested too many proxy handles from the pool
.TP
EIdle
Proxy is currently in the idle state\&.
.TP
EInit
Evaluation of the init script failed\&.
.TP
EDead
Proxy handle is currently not connected to any process\&.
.TP
EBusy
Proxy handle is currently busy with the evaluation\&.
.PP
.SH EXAMPLES
.PP
The following demonstrates sending a script to a remote proxy:
.CS


set handle [\fBns_proxy\fR get myproxy]
\fBns_proxy\fR eval $handle {info patchlevel}
\fBns_proxy\fR release $handle

.CE
Alternatively, instead of using the scalar handle you can use
the handle directly as a Tcl command:
.CS


set handle [\fBns_proxy\fR get myproxy]
$handle {info patchlevel}
rename $handle ""

.CE
The following demonstrates using multiple proxies:
.CS


\fBns_proxy\fR configure myproxy -maxslaves 10
set handles [\fBns_proxy\fR get myproxy -handle 10]
foreach h $handles {
    $h {puts "alive: [pid]"}
}
\fBns_proxy\fR cleanup

.CE
.SH "SEE ALSO"
ns_job
.SH KEYWORDS
exec, module, nsproxy, pools, proxy, server built-in