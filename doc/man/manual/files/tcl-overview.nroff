'\"
'\" Generated from file 'tcl-overview\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "tcl-overview" n 4\&.99\&.23 manual "NaviServer Manual"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
tcl-overview \- NaviServer Tcl Overview
.SH DESCRIPTION
This chapter contains general information about using Tcl whether you
are using the ADP approach or the Tcl Libraries approach, both of
which use the same features of Tcl\&.
.SH "WHAT IS TCL?"
Tcl is a programming system developed by John Ousterhout at the
University of California, Berkeley\&. According to Dr\&. Ousterhout:
.PP
Tcl is a simple scripting language for controlling and extending
applications; its name stands for "tool command language"\&. Tcl
provides generic programming facilities, such as variables and loops
and procedures, that are useful in a variety of applications\&.
Furthermore, Tcl is embeddable\&. Its interpreter is a library of C
procedures that can easily be incorporated into applications, and each
application can extend the core Tcl features with additional commands
for that application\&.
.PP
NaviServer supports the Tcl 8\&.* commands\&. When you write NaviServer
extensions in Tcl, you use the core functionality of Tcl as well as a
set of NaviServer-specific Tcl functions\&. For example, there is a NaviServer Tcl function called ns_conn that allows your Tcl script to
obtain information about the current connection\&. In addition,
functions are available for returning results to Web clients,
accessing databases, and managing the permissions (access control)
system\&.
.PP
This book describes the two different methods for extending NaviServer
with Tcl, using NaviServer Dynamic Pages (Chapter 2) and Tcl libraries
(see Chapter 3), plus general information on using Tcl with either
method (see Chapter 4)\&. It also provides a reference for NaviServer's
Tcl API (see Chapter 5)\&.
.PP
.SS "RECOMMENDED READING"
.PP
For more information on the Tcl language, we recommend the following
sources:
.PP
.IP \(bu
Practical Programming in Tcl and Tk, by Brent B\&. Welch (Prentice Hall PTR, 1995)
.sp
.IP \(bu
Tcl and the Tk Toolkit, by John K\&. Ousterhout (Addison-Wesley, 1994)
.sp
.IP \(bu
For the complete manual pages for the Tcl v7\&.6 commands, visit the
web site http://www\&.scriptics\&.com/man\&.
.sp
.IP \(bu
Philip Greenspun's web site, http://www-swiss\&.ai\&.mit\&.edu/wtr/dead-trees/, which includes
chapters from his book, Database Backed Web Sites, The Thinking Person's Guide to Web Publishing,
and numerous examples of NaviServer Tcl database applications\&.
.sp
.IP \(bu
The web site: http://www\&.yahoo\&.com/Computers_and_Internet/Programming_Languages/Tcl_Tk
.PP
.PP
.SH "WHY USE TCL?"
.PP
You can extend NaviServer using Tcl, C, or CGI\&. However, using Tcl has
the following advantages:
.PP
.IP \(bu
Creating new Tcl scripts is very easy\&. You can embed Tcl scripts
directly into HTML pages using NaviServer Dynamic Pages (ADPs), or
you can create \&.tcl files and register them to handle URLs or URL
hierarchies\&.
.sp
.IP \(bu
Tcl's scripting language is easier to learn and use than compiled
programming languages\&. It provides general programming
capabilities, such as variables, loops, and procedures, but it
doesn't require strong type definitions or compilation\&. Plus,
NaviServer's Tcl interface provides a complete set of Tcl
extensions specifically oriented towards web server applications,
such as returning content to the client, accessing form data,
accessing databases, and logging\&.
.sp
.IP \(bu
Many of the basic NaviServer services are implemented as Tcl
scripts\&. In fact, most of the database operations such as handling
database inserts, queries, and updates, are written as Tcl
scripts\&. Not only has the Tcl interface greatly reduced the
development time for the NaviServer engineering team, it also
allows you to easily modify the basic database operations by
simply editing the Tcl scripts that implement the functionality\&.
.sp
.IP \(bu
The Tcl and C interfaces typically provide better performance than
CGI\&. However, if you have existing CGI programs, you may want to
use NaviServer's CGI interfaces to take advantage of
previously-existing code\&.
.PP
.PP
The C interface for NaviServer is described in the NaviServer C
Developer's Guide, and the CGI interface is described in the NaviServer
Administrator's Guide\&.
.PP
.SH "ADPS AND TCL LIBRARIES"
.PP
There are two ways to extend NaviServer using Tcl, and each is
better-suited to different situations:
.PP
.IP \(bu
NaviServer Dynamic Pages (ADPs): ADPs allow you to embed Tcl
scripts directly into HTML pages\&. The script(s) are interpreted
dynamically when the page is accessed\&. ADPs are ideal in
situations where you want to generate all or part of a specific
page dynamically\&. You can re-use code by storing Tcl scripts in
Tcl libraries and invoking them from within multiple ADPs\&. You can
also include files and parse other ADPs from within your ADPs\&.
.IP \(bu
Tcl Libraries: The alternative to embedding Tcl scripts in HTML
pages using ADPs, is to store Tcl scripts in Tcl libraries\&. You
can define scripts that can be called from ADPs, schedule
procedures to run at certain times, register scripts to handle
specific URLs or URL hierarchies, register scripts to handle all
URLs with a specific file extension, and register filters to be
run in addition to a URL's registered procedure\&.
.PP
.SH "TCL INTERPRETERS"
During NaviServer initialization, only one interpreter
exists\&. While modules are loaded and initialized, they may add
procedures to the interpreter\&. When initialization is complete (all
modules are loaded and all Tcl libraries have been executed),
NaviServer creates from this a blueprint consisting of the
preloaded modules (mostly Tcl files)\&.
This blueprint is provided later to every thread (e\&.g\&. connection
threads, or background threads) upon initialization\&.
.PP
IMAGE: blueprint3 NaviServer Blueprint
.PP
Figure: NaviServer Blueprint (per server)
.PP
Blueprints are used to reduce latency\&. When e\&.g\&. a connection
thread processes an incoming request, all the basic Tcl code is
already available and can be used by the interpreter without
further loading operations\&.
.PP
In order to update the blueprints, NaviServer provides built-in
support for updating via the command \fBns_eval\fR or via the lower
level command \fBns_ictl\fR\&.
.SH "GLOBAL VARIABLES"
The NaviServer blueprint contains Tcl functions, XOTcl/NX classes
and objects and also namespaced variables\&. This are all Tcl
variables, which are not in the topmost namespace "::"\&. The
top-level variables are treated as "scratch variables", which are
flushed automatically after every request\&. The global variables are
often used for providing values for templating; cleaning these
automatically can avoid unexpected interactions\&.
.PP
In addition of the per-interpreter variables, NaviServer provides
shared variables, which can be accessed via the nsv_* interface
(see below for an example)\&. When such a variable is altered, its
value is immediately available in all threads\&.
.SH "SHARING FILES BETWEEN INTERPRETERS"
To share variables between the interpreters in a group, use the Tcl
nsv_* command\&.
.PP
For example:
.CS


    #init time:
    nsv_set \&. sharedFile [open myfile\&.dat]

.CE
.PP
You must manually close the shared file (by performing a close) when
it is no longer needed or when the server is shut down\&.
.PP
Note that there is no implicit locking between interpreters\&. As a consequence
one interpreter can be performing a \fBgets\fR command on the
shared file at the same time another interpreter performs a \fBclose\fR on
the same file\&. The results are unpredictable, and could potentially
cause a core dump\&. To avoid this situation, use a mutex to protect
access to the file whenever it is accessed\&.
.PP
For example:, at initialization time (for example, in your init\&.tcl
script), open a shared file and create a mutex:
.PP
.CS


    nsv_set \&. sharedLock [ns_mutex create]
    nsv_set \&. sharedFile [open myfile\&.dat]

.CE
.PP
At run time, use the mutex to protect any actions you perform on the
shared file:
.PP
.CS


    ns_mutex lock [nsv_get \&. sharedLock]
    set sharedFile  [nsv_get \&. sharedFile]
    puts $sharedFile \&.\&.\&.
    gets $sharedFile \&.\&.\&.
    ns_mutex unlock [nsv_get \&. sharedLock]

.CE
.PP
At shutdown (for example, in your shutdown procedure registered with
ns_atshutdown), close the file and destroy the lock:
.PP
.CS


    close [nsv_get \&. sharedFile]
    ns_mutex destroy [nsv_get \&. sharedLock]

.CE
.PP
.SH "WORKING WITH NS_SET AND FORM DATA"
.PP
An NaviServer operation procedure often manipulates sets of key-value
pairs of string data, for example:
.PP
.IP \(bu
rows of data from the database
.IP \(bu
HTTP header information
.IP \(bu
HTML form data
.PP
.PP
.SS "NS_SET DATA STRUCTURE"
.PP
In the NaviServer C API these data are manipulated using the ns_set
data structure\&. In the Tcl API the ns_set command can be used to
manipulate underlying ns_set data structures that are generated by the
NaviServer communications layer or the database services module\&.
.PP
The example below shows a typical use of the ns_set Tcl command to
manipulate ns_set structures\&.
.CS


   # Example 2: Show header data
    #
    # Things to notice:
    # * The same function is registered for two different URLs
    # with different context\&.
    #
    # * The headers are pulled out of the conn using the
    # ns_conn function\&.
    #
    # * The value for a particular header line is extracted
    # with "ns_set iget" (case insensitive get)\&.

    ns_register_proc GET /showbrowser showheader User-Agent
    ns_register_proc GET /showhost    showheader Host

    proc showheader {key} {
          set value [ns_set iget [ns_conn headers] $key]
          ns_return 200 text/plain "$key: $value"
    }

.CE
.PP
.SH "TCL EXAMPLES"
.SS "EXAMPLE 1: HELLO"
The following example script implements a simple request procedure
which returns 'Hello World'\&.
.CS


 # Example 1: Hello World
 #
 # This simple operation just returns a plain text message\&.
 #
 # Things to notice:
 #
 # * ns_register_proc takes as arguments:
 #   * the HTTP method
 #   * the URL that the procedure handles
 #   * the procedure that is executed
 #
 # * ns_return takes as arguments:
 #   * the passed in connection
 #   * a return status, in this case 200 for success
 #   * a MIME type
 #   * the actual string to return
 #
 # * ns_return properly formats the HTTP response for you\&.

 ns_register_proc GET /example/hello hello

 proc hello {} {
   ns_return 200 text/plain "Hello World"
 }

.CE
.SS "EXAMPLE 2: SHOWHDRS"
The following example script shows how to access the HTTP headers sent
by the client within a Tcl script\&.
.CS


 # Example 2: Show header data
 #
 # Things to notice:
 #
 # * The same function is registered for two different URLs
 #   with different context\&.
 #
 # * The headers are pulled out of the conn using the
 #   ns_conn function\&.
 #
 # * The value for a particular header line is extracted
 #   with "ns_set iget", the case insensitive counterpart to
 #   "ns_set get"\&.

 ns_register_proc GET /showbrowser showheader User-Agent
 ns_register_proc GET /showhost    showheader Host

 proc showheader {key} {
    set value [ns_set iget [ns_conn headers] $key]
    ns_return 200 text/plain "$key: $value"
 }

.CE
.SS "EXAMPLE 3A: GENSTORY"
The following example script provides two request procedures\&. The
first procedure returns an HTML page for collecting a few fields of
data from the user\&. The second procedure utilizes the data to generate
a short story\&.
.CS


 # Example 3a: Form generation and handling
 #
 # Two functions are registered\&. One generates and
 # returns an HTML form, and the other processes
 # the data in the form\&.
 #
 # Things to notice:
 #
 # * Different functions are registered to the same
 #   URL with different methods\&.  Note that some browsers
 #   do not cache results properly when you do this\&.
 #
 # * The genstory function returns an error status
 #   (500) if the client doesn't pass in any form data\&.
 #
 # * Form data is stored in an ns_set, and accessed
 #   like any other set (e\&.g\&., header data)\&.
 #
 # * A counter is used to loop through all the key
 #   value pairs in the form\&.

 ns_register_proc GET  /example/genstory genstoryform
 ns_register_proc POST /example/genstory genstory

 proc genstoryform {} {
  ns_return 200 text/html \\
 "<html>
 <head>
 <title>Automatic Story Generator</title>
 </head>
 <body>
 <h1>Automatic Story Generator</h1>
 <form action='genstory' method='POST'>
 Noun: <input type='text' name='noun1'><br>
 Noun: <input type='text' name='noun2'><br>
 Name: <input type='text' name='name1'><br>
 Name: <input type='text' name='name2'><br>
 Adjective: <input type='text' name='adjective1'><br>
 Adjective: <input type='text' name='adjective2'><br>
 Verb: <input type='text' name='verb1'><br>
 Verb: <input type='text' name='verb2'><br>
 <p><input type='submit' value='Generate'>
 </form>
 </body></html>
 "}

 proc genstory {} {
  set formdata [ns_conn form]

  if {$formdata eq ""} {
    ns_return 200 text/plain "Need form data!"
    return
  }

  # Build up a human-readable representation of the form data\&.

  set hrformdata "<dl>"
  set size [ns_set size $formdata]
  for {set i 0} {$i < $size} {incr i} {
    append hrformdata "<dt>[ns_set key $formdata $i]</dt><dd>[ns_set value $formdata $i]</dd>"
  }
  append hrformdata "</dl>"

  ns_return 200 text/html \\
 "<html>
 <head>
 <title>The story of [ns_set get $formdata name1] and
 [ns_set get $formdata name2]</title>
 </head>
 <body>
 <h1>The story of [ns_set get $formdata name1] and [ns_set get $formdata name2]</h1>
 <p>Once upon a time [ns_set get $formdata name1] and
 [ns_set get $formdata name2] went for a
 walk in the woods looking for a [ns_set get $formdata noun1]\&.
 [ns_set get $formdata name1] was
 feeling [ns_set get $formdata adjective1] because
 [ns_set get $formdata name2] was so
 [ns_set get $formdata adjective2]\&.  So
 [ns_set get $formdata name1] decided to
 [ns_set get $formdata verb1] [ns_set get $formdata name2]
 with a [ns_set get $formdata noun2]\&.  This made
 [ns_set get $formdata name2] [ns_set get $formdata verb2]
 [ns_set get $formdata name1]\&.
 <p><center>The End</center>
 The form data that made this possible:<br>
 $hrformdata
 </body></html>"
 }

.CE
.SS "EXAMPLE 3B: PAGETCL/GENSTORY"
The following example script implements the same story generating
function of genstory (the previous example) but is implemented as a
Tcl page instead of a library Tcl function\&. Save the following
snippet as \fIgenstory\&.tcl\fR as well as the associated HTML file
\fIgenstory\&.html\fR under the pages directory\&.
.CS


 # Example 3b: Form generation and handling
 #
 # This operation generates a story based on the
 # form data submitted from the form genstory\&.html\&.
 #
 # Things to notice:
 #
 # * This file should be stored with the HTML pages
 #   of the server\&.  When a client requests the URL corresponding
 #   to the file, the NaviServer sets the "conn" variable and
 #   evaluates the Tcl\&.
 #
 # * An error status (500) is returned if the client doesn't
 #   doesn't pass in any form data\&.
 #
 # * Form data is stored in an ns_set, and accessed
 #   like any other set (e\&.g\&., header data)\&.
 #
 # * A counter is used to loop through all the key
 #   value pairs in the form\&.

 set formdata [ns_conn form]

 if {$formdata eq ""} {
    ns_return 200 text/plain "Need form data!"
    return
 }

 # Build up a human-readable representation of the form data\&.

 set hrformdata "<dl>"
 set size [ns_set size $formdata]
 for {set i 0} {$i < $size} {incr i} {
    append hrformdata "<dt>[ns_set key $formdata $i]</dt>\\
        <dd>[ns_set value $formdata $i]</dd>"
 }
 append hrformdata "</dl>"

 ns_return 200 text/html \\
 "<html>
 <head>
 <title>The story of [ns_set get $formdata name1] and
 [ns_set get $formdata name2]</title>
 </head>
 <body>
 <h1>The story of [ns_set get $formdata name1] and
 [ns_set get $formdata name2]</h1>
 <p>Once upon a time [ns_set get $formdata name1] and
 [ns_set get $formdata name2] went for a
 walk in the woods looking for a [ns_set get $formdata noun1]\&.
 [ns_set get $formdata name1] was
 feeling [ns_set get $formdata adjective1] because
 [ns_set get $formdata name2] was so
 [ns_set get $formdata adjective2]\&.  So
 [ns_set get $formdata name1] decided to
 [ns_set get $formdata verb1] [ns_set get $formdata name2]
 with a [ns_set get $formdata noun2]\&.  This made
 [ns_set get $formdata name2] [ns_set get $formdata verb2]
 [ns_set get $formdata name1]\&.
 <p><center>The End</center>
 The form data that made this possible:<br>
 $hrformdata
 </body></html>"

.CE
Here's the associated HTML file \fIgenstory\&.html\fR:
.CS


 <html>
 <head>
 <title>Automatic Story Generator</title>
 </head>
 <body>
 <h1>Automatic Story Generator</h1>
 <form action='genstory\&.tcl' method='POST'>
 Noun: <input type='text' name='noun1'><br>
 Noun: <input type='text' name='noun2'><br>
 Name: <input type='text' name='name1'><br>
 Name: <input type='text' name='name2'><br>
 Adjective: <input type='text' name='adjective1'><br>
 Adjective: <input type='text' name='adjective2'><br>
 Verb: <input type='text' name='verb1'><br>
 Verb: <input type='text' name='verb2'><br>
 <p><input type='submit' value='Generate'>
 </form>
 </body>
 </html>

.CE
.SS "EXAMPLE 4: REDIRECT"
The following example script shows how to use a NaviServer simple
response command (in this case, ns_returnredirect) and the equivalent
code when sending raw data to the client\&.
.CS


 # Example 4: Implementing redirects with ns_respond and
 # ns_write
 #
 # /example/not_here uses ns_respond to return an HTTP
 #   redirect to /example/finaldest\&.
 # /example/not_here2 does the same thing using ns_write
 # /example/not_here3 does the same thing with
 #   ns_returnredirect
 #
 # Things to notice:
 #
 # * When you use ns_write, you need to compose the
 #   entire response\&.
 #
 # * "ns_conn location" returns the http://hostname
 #   part of the URL that you can use to generate
 #   fully qualified URLs\&.
 #
 # * ns_returnredirect is a lot simpler than either
 #   ns_respond or ns_write\&.

 ns_register_proc GET /example/not_here  not_here
 ns_register_proc GET /example/not_here2 not_here2
 ns_register_proc GET /example/not_here3 not_here3
 ns_register_proc GET /example/finaldest finaldest

 proc not_here {} {
  set headers [ns_set new myheaders]
  ns_set put $headers Location \\
      [ns_conn location]/example/finaldest
  ns_respond -status 302 -type text/plain \\
      -string "Redirection" -headers $headers
 }

 proc not_here2 {} {
  set content \\
 "<html><head><title>Redirection</title></head><body>
 <h1>Redirection</h1>The actual location of what you were looking for is
 <a href='[ns_conn location]/example/finaldest'> here\&.</a>
 </body></html>"

  ns_write  \\
 "HTTP/1\&.0 302 Document follows
 MIME-Version: 1\&.0
 Content-Type: text/html
 Content-Length: [string length $content]
 Location: [ns_conn location]/example/finaldest

 $content"
 }

 proc not_here3 {} {
  ns_returnredirect [ns_conn location]/example/finaldest
 }

 proc finaldest {} {
  ns_return 200 text/plain \\
      "You have arrived at the final destination\&."
 }

.CE
.SS "EXAMPLE 5: DESCTABLE"
The following example script provides a request procedure which
describes the columns of a database table using the NaviServer
"ns_tableinfo" command \&.
.CS


 # Example 5: Describing a database table
 #
 # /example/describetable prints out a column-by-column
 #   description of a database table\&.  The database
 #   pool name and table name are specified at the end
 #   of the URL -- e\&.g\&.,
 #
 #       /example/describetable/nsdbpool/ns_users
 #
 # Note: You must have the nsdb module loaded into your virtual
 #       server for this example to work\&.
 #
 # Things to notice:
 #
 # * ns_returnbadrequest returns a nicely formatted message
 #   telling the client they submitted an invalid request\&.
 #
 # * "ns_conn urlv" returns a Tcl array whose elements are the
 #   slash-delimited parts of the URL\&.
 #
 # * The describetable function loops through all the columns
 #   and uses "ns_column valuebyindex" to get the type of each
 #   one\&.
 #
 # * ns_returnnotice nicely formats the return value\&.

 ns_register_proc GET /example/describetable describetable

 proc describetable {} {
    if {[ns_conn urlc] != 4} {
        return [ns_returnbadrequest "Missing table name and/or poolname"]
    }
    set pool [lindex [ns_conn urlv] 2]
    if {$pool ni [ns_db pools]} {
        return [ns_returnbadrequest "Pool $pool does not exist"]
    }
    set db [ns_db gethandle $pool]
    set table [lindex [ns_conn urlv] 3]
    if {[info command ns_table] eq ""} {
       set output "Driver [ns_db driver $db] does not support command ns_table"
    } else {
        set tinfo [ns_table info $db $table]
        if {$tinfo eq ""} {
            return [ns_returnbadrequest "Table $table does not exist"]
        }
        set output "<dl>"
        set size [ns_column count $tinfo]
        for {set i 0} {$i < $size} {incr i} {
            append output "<dt>[ns_column name $tinfo $i] \\
                    <dd>[ns_column typebyindex $tinfo $i]</dd>"
        }
        append output "</dl><hr>"
    }
    ns_returnnotice 200 "Table $table in pool $pool" $output
 }

.CE
.SS "EXAMPLE 6: GETEMPSM"
The following example script shows how to query a table in the
database\&.
.CS


 # Example 6: Getting data from the database
 #
 # /example/getemps queries a database in the default
 # pool and returns a list of all the employees listed
 # in the employees table\&.  It assumes a table called
 # employees exists with the column emp_name\&.
 #
 # Note: You must have the nsdb module loaded into your virtual
 #       server for this example to work\&.
 #
 # Things to notice:
 #
 # * Use "ns_db gethandle" to get a handle for the database
 #   from the default database pool of the virtual server\&.
 #
 # * Use "ns_db select" to query the database and
 #   "ns_db getrow" to retrieve data\&.
 #
 # * Rows are returned as ns_sets\&.
 #

 ns_register_proc GET /example/getemps getemps

 proc getemps {} {
        set ul "<ul>"
        set db [ns_db gethandle [ns_config [ns_dbconfigpath] "DefaultPool"]]
        set row [ns_db select $db "select emp_name from employees order by emp_name;"]
        while { [ns_db getrow $db $row] } {
            append ul "<li>[ns_set get $row emp_name] \\n"
        }
        append ul "</ul>"
        ns_returnnotice 200 "Employee list" $ul
 }


.CE
.SS "EXAMPLE 7: WINCGI"
The following example script is a simple emulation of the WebSite
WinCGI interface\&. Notice that this is just a demo, since the NaviServer
modules nscgi provides a much simpler way to interface via CGI (when
this is necessary)\&.
.CS


 #
 # Example 7: simple emulation of the WebSite WinCGI interface
 #
 # This Tcl script emulates the WinCGI interface of the WebSite server\&.
 # To use, move this file to your Tcl library directory (normally the
 # modules/tcl directory of the NaviServer directory), set the
 # following nsd\&.ini variables in the [ns\\server\\<server-name>\\wincgi]
 # section, and restart the server\&.
 #
 # key     default    description
 # ---     -------    -----------
 # prefix  /cgi-win   URL prefix for WinCGI\&.
 # debug   off        Set to on to keep temp files for debugging\&.
 # gmtoff  0          Minutes West of GMT for the "GMT Offset" variable\&.
 # dir     c:\\wincgi  Directory of WinCGI programs\&.
 #
 #
 # Note:  This script is unsupported and not a complete emulation of the
 # WebSite WinCGI interface\&.  In particular, not all the WinCGI variables
 # are set\&.  Full support for WinCGI will be incorporated into the nscgi
 # module in a future NaviServer release\&.
 #

 #
 # Fetch the variables from the configuration file\&.
 #
 global WinCGI
 set WinCGI(section) "ns\\\\server\\\\[ns_info server]\\\\wincgi"
 if {[set WinCGI(prefix) [ns_config $WinCGI(section) prefix]] eq ""} {
    set WinCGI(prefix) /cgi-win
 }
 if {[set WinCGI(dir) [ns_config $WinCGI(section) dir]] eq ""} {
    set WinCGI(dir) [ns_info home]/$WinCGI(prefix)
 }
 if {[set WinCGI(gmtoff) [ns_config $WinCGI(section) gmtoff]] eq ""} {
    set WinCGI(gmtoff) 0
 }
 if {[set WinCGI(debug) [ns_config -bool $WinCGI(section) debug]] eq ""} {
    set WinCGI(debug) 0
 }


 #
 # Register the win-cgi procedure to handle requests for WinCGI executables\&.
 #
 ns_register_proc POST $WinCGI(prefix)/*\&.exe win-cgi
 ns_register_proc GET $WinCGI(prefix)/*\&.exe win-cgi


 #
 # win-cgi - The Tcl request procedure which emulates WinCGI\&.
 #
 proc win-cgi {} {
    global WinCGI

    # The program is the second part of the WinCGI URL\&.
    set args [join [split [ns_conn query] &]]
    set pgm [lindex [ns_conn urlv] 1]
    regsub -all {\\+} $args " " args
    foreach e [split $WinCGI(dir)/$pgm /] {
            if {$e ne ""} {lappend exec $e}
    }
    set exec [join $exec ]
    if ![file executable $exec] {
            return [ns_returnnotfound]
    }

    # WinCGI requires a few temporary files\&.
    set ini [ns_mktemp]
    set inp [ns_mktemp]
    set out [ns_mktemp]

    # Copy the request content to the input file\&.
    set fp [open $inp w]
    ns_writecontent $fp
    set len [tell $fp]
    close $fp

    # Create the WinCGI variables \&.ini file\&.
    set fp [open $ini w]
    puts $fp {[CGI]}
    puts $fp \\
 "Request Protocol=HTTP/1\&.0
 Request Method=[ns_conn method]
 Executable Path=$WinCGI(prefix)/$pgm
 Server Software=[ns_info name]/[ns_info version]
 Server Name=[ns_info name]
 Server Port=[ns_info version]
 Server Admin=[ns_config NaviServer WebMaster]
 CGI Version=CGI/1\&.2 (Win)
 Remote Address=[ns_conn peeraddr]
 Authentication Method=Basic
 Authentication Realm=[ns_conn location]
 Content Type=application/x-www-form-urlencoded
 Content Length=$len"
    puts $fp ""
    puts $fp {[System]}
    puts $fp \\
 "GMT Offset=$WinCGI(gmtoff)
 Debug Mode=Yes
 Output File=$out
 Content File=$inp"

    # Set any POST or query form variables\&.
    puts $fp ""
    puts $fp {[Form Literal]}
    set form [ns_conn form]
    if {$form ne ""} {
            for {set i 0} {$i < [ns_set size $form]} {incr i} {
                    set key [ns_set key $form $i]
                    set value [ns_set value $form $i]
                    puts $fp "$key=$value"
            }
    }

    # Set the accept headers and accumulate the extra headers\&.
    puts $fp ""
    puts $fp {[Accept]}
    set headers [ns_conn headers]
    set extras ""
    for {set i 0} {$i < [ns_set size $headers]} {incr i} {
            set key [ns_set key $headers $i]
            set ukey [string toupper $key]
            set value [ns_set value $headers $i]
            if {$ukey eq "ACCEPT"} {
                    puts $fp "$value=Yes"
            } elseif {$key ne "CONTENT-LENGTH" && $key ne "CONTENT-TYPE"} {
                    append extras "$key=$value\\n"
            }
    }
    puts $fp ""
    puts $fp {[Extra Headers]}
    puts $fp $extras
    close $fp

    # Execute the WinCGI program\&.
    # NB:  "catch" the exec and open because a WinCGI
    # program can be misbehaved, returning a nonzero
    # exit status or not creating the output file\&.
    catch {exec "$exec $ini $inp $out $args"}
    if [catch {set fp [open $out]}] {
            ns_returnerror 500 "WinCGI exec failed"
    } else {
            set type text/html
            set status 200
            while {[gets $fp line] > 0} {
                    set line [string trim $line]
                    if {$line eq ""} break
                    set head [split $line :]
                    set key [string tolower [string trim [lindex $head 0]]]
                    set value [string trim [lindex $head 1]]
                    if {$key eq "content-type"} {
                            set type $value
                    } elseif {$key eq "location"} {
                            set location $value
                    } elseif {$key eq "status"} {
                            set status $status
                    }
            }
            set page [read $fp]
            close $fp

            if [info exists location] {
                    ns_returnredirect $location
            } else {
                    ns_return $status $type $page
            }
    }

    if $WinCGI(debug) {
            ns_log Notice "CGI $pgm: ini: $ini, inp: $inp, out: $out"
    } else {
            file delete -- $ini
            file delete -- $inp
            file delete -- $out
    }
 }

.CE
.SH KEYWORDS
ns_set, nsdb
