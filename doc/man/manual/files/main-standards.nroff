'\"
'\" Generated from file 'main-standards\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "main-standards" n 4\&.99\&.23 manual "NaviServer Manual"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
main-standards \- Engineering Standards Manual
.SH DESCRIPTION
Contributed by George Nachman\&.
.PP
Based on the Tcl/Tk Engineering Manual by John K\&. Ousterhout
.PP
.SH INTRODUCTION
This manual is based on the \fITcl/Tk Engineering Manual\fR
by John K\&. Ousterhout that is available at
\fIhttp://www\&.activestate\&.com/ActiveState\fR\&.
Most of this document is a subset of what his manual
specifies, with the goal of being more practical and up-to-date than
the original\&. For example, it is assumed that only an ANSI compiler
will be used, whereas the Ousterhout's manual describes conventions
that will also work with non-ANSI compilers\&. The
\fITcl/Tk Engineering Manual\fR
is recommended reading, particularly with respect to the section on
code documentation, which is not reproduced here\&.
.PP
.SH "OVERALL STRUCTURE"
Each module will be named ns\fIxxx\fR, where \fIxxx\fR is a short
name that describes the module\&. Each module will have its own
directory, and contain at least the following files:
.IP \(bu
ns\fIxxx\fR\&.c
.IP \(bu
Makefile
.PP
.PP
If a module exports symbols, then a header file by the name of
ns\fIxxx\fR\&.h should also be in that directory\&.
.PP
.SH "MAKEFILE STRUCTURE"
Use this as a template for module makefiles:
.CS


 #
 # nsexample --
 #
 #      Example NaviServer module Makefile\&.
 #

 #
 # NaviServer's location
 #
 #  Since your module probably doesn't live inside the "naviserver"
 #  directory, you can tell make where to find NaviServer\&.
 #
 #NAVISERVER   =  /usr/local/ns
 NAVISERVER    =  \&.\&./naviserver

 #
 # File name of binary loadable module
 #
 MOD           =  nsexample\&.so

 #
 # Object files for modules (required with MOD)
 #
 MODOBJS       =  nsexample\&.o

 #     MODNAME     Unique name of module
 #     TCL         List of module shared Tcl files
 #     LIBNM       Root name of dynamic library (without lib prefix or extension)
 #     LIBOBJS     List of library object files (required with LIBNM)
 #     LIBHDRS     List of public header files to install (required with module LIBNM)
 #     PGM         Name of executable program
 #     PGMOBJS     List of program object files (required with PGM)
 #     HDRS        Header files which objects depend on
 #     MODLIBS     Extra module link libraries
 #     LIBLIBS     Extra dynamic library link libraries
 #     PGMLIBS     Extra program link libraries
 #     INSTALL     Extra install directive(s)
 #     CLEAN       Extra clean directive(s)
 #     DESTDIR     Root directory for install
 #
 #     At least one of PGM, MOD, or LIBNM must be defined\&.  For backwards compatibility,
 #     MODOBJS will default to OBJS and MODINST can be used for module install\&.


 include  $(NSHOME)/include/Makefile\&.module

.CE
.SH "HEADER FILE STRUCTURE"
Use this as a template for all header files:
.CS


 /*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1\&.1 (the "License"); you may not use this file except in
 * compliance with the License\&. You may obtain a copy of the License at
 * http://mozilla\&.org\&.
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied\&. See
 * the License for the specific language governing rights and limitations
 * under the License\&.
 *
 * Alternatively, the contents of this file may be used under the terms
 * of the GNU General Public License (the "GPL"), in which case the
 * provisions of GPL are applicable instead of those above\&.  If you wish
 * to allow use of your version of this file only under the terms of the
 * GPL and not to allow others to use your version of this file under the
 * License, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the GPL\&.
 * If you do not delete the provisions above, a recipient may use your
 * version of this file under either the License or the GPL\&.
 */

 /*
 * file\&.h --
 *
 * 	Description of file\&.
 *
 */

 #ifndef FILE_H
 #define FILE_H


 /*
 * The following constants\&.\&.\&.
 */

 #define \&.\&.\&.

 /*
 * The following structure defines\&.\&.\&.
 */

 typedef struct \&.\&.\&.

 /*
 * Exported functions
 */

 extern \&.\&.\&.

 #endif /* FILE_H */

.CE
.PP
Header files never contain static symbols\&.
.SH "CODE FILE STRUCTURE"
Each source code file should contain a related set of procedures\&. The
most manageable size for files is usually in the range of 500-2000
lines\&. Closely related functions should be placed as close together as
possible\&.
.PP
API functions (ns_*) come first; exported functions that are not API
calls (Ns*) come after those; static functions come last\&. Logical
groups of functions can be separated like this:
.PP
.CS


 /*
 *==========================================================================
 * This is where we torque the wingnut on the widget\&.
 *==========================================================================
 */

.CE
.PP
Use this as a template for all code files:
.CS


 /*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1\&.1 (the "License"); you may not use this file except in
 * compliance with the License\&. You may obtain a copy of the License at
 * http://mozilla\&.org/\&.
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied\&. See
 * the License for the specific language governing rights and limitations
 * under the License\&.
 *
 * Alternatively, the contents of this file may be used under the terms
 * of the GNU General Public License (the "GPL"), in which case the
 * provisions of GPL are applicable instead of those above\&.  If you wish
 * to allow use of your version of this file only under the terms of the
 * GPL and not to allow others to use your version of this file under the
 * License, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the GPL\&.
 * If you do not delete the provisions above, a recipient may use your
 * version of this file under either the License or the GPL\&.
 */

 /*
 * file\&.c --
 *
 * 	Description of file\&.
 */

 #include "file\&.h"

 /*
 * The following constants\&.\&.\&.
 */

 #define \&.\&.\&.

 /*
 * The following structure defines\&.\&.\&.
 */

 typedef struct \&.\&.\&.

 /*
 * Local functions defined in this file
 */

 static int FunctionName(int x);

 /*
 * Static variables defined in this file
 */

 static int nsNumFooBar;     /* Number of foobars allocated */
 \&.\&.\&.

 /*
 *==========================================================================
 * API functions
 *==========================================================================
 */

 (API function definitions go here)

 /*
 *==========================================================================
 * Exported functions
 *==========================================================================
 */

 (Exported, non-api functions go here)

 /*
 *==========================================================================
 * Static functions
 *==========================================================================
 */

 (Static functions go here)

.CE
.PP
Source files should never contain extern statements; those belong in
header files (called file\&.h in the above template)\&.
.SH "FUNCTION DEFINITIONS"
Function definitions should follow this template:
.CS


   /*
    *----------------------------------------------------------------------
    * FunctionName --
    *
    * 	Description of function\&.
    *
    * Results:
    *	This function returns \&.\&.\&.
    *
    * Side effects:
    *	A new thread will be created\&.
    *
    *----------------------------------------------------------------------
    */

   static int
   FunctionName(int x)
   {
 	\&.\&.\&.
   }

.CE
.PP
All functions definitions begin on a new page (which is to say they
should be preceded by a control-L character)\&. All functions must be
typed: use void if the function returns no result\&. The second line
gives the function's name and argument list\&. If there are many
arguments, they should spill onto additional lines as such:
.CS


   static int
   FunctionThatTakesLotsOfParameters(int a, int b, int c, int d, int e,
                                     int f, int g)
   {
 	\&.\&.\&.
   }

.CE
.PP
The same rule applies to prototypes\&.
.SH "PARAMETER ORDER"
Function parameters may be divided into three categories\&. \fIIn\fR
parameters only pass information into the function (either directly or
by pointing to information that the function reads)\&. \fIOut\fR
parameters point to things in the caller's memory that the function
modifies\&. \fIIn-out\fR parameters do both\&. Below is a set of rules
for deciding on the order of parameters to a function:
.IP [1]
Parameters should normally appear in the order in, in/out, out,
except where overridden by the rules below\&.
.IP [2]
If there is a group of functions, all of which operate on
structures of a particular type--such as a hash table--the token for
the structure should be the first argument to each of the functions\&.
.IP [3]
When two parameters are the address of a callback function and a
context value (or ClientData value) to pass to that function, the
function address should appear in the argument list immediately before
the context/ClientData\&.
.IP [4]
If a callback function takes a context/ClientData argument (and
all callbacks should), the context/ClientData argument should be the
first argument to the procedure\&. Typically the context/ClientData is a
pointer to the structure managed by the callback, so this is really
the same as rule 2\&.
.IP [5]
In/out parameters should not be used without a \fIvery \fRgood
reason\&.
.PP
.SH "NAMING CONVENTIONS"
.IP [1]
Be consistent\&. Use the same name to refer to the same thing
everywhere\&. For example, in the Tcl implementation the name
\fIinterp\fR is used consistently for pointers to the user-visible
Tcl_Interp structure\&.
.IP [2]
Make sure a function name describes what the function actually
does\&. Will the name make sense out of context?
.IP [3]
Sometimes it is appropriate to use one-letter variables, such as a
for-loop control variable called \fIi\fR\&. For anything more complex,
a short descriptive name should be used\&.
.PP
.SH "BASIC SYNTAX RULES"
.IP [1]
Variable names always start with a lowercase letter\&. Function and
type names always start with an uppercase letter\&.
.IP [2]
In multi-word names, the first letter of each word after the first
is in uppercase (usually referred to as camel case)\&. Example:
.CS


   int nsThreadTimeout;

.CE
.IP [3]
Any name that refers to a pointer ends in Ptr\&. If it is a pointer
to a pointer, then it ends in PtrPtr\&. Exceptions to this rule include
opaque handles for structures (such as ns_ModLogHandle) and char *
variables that refer to null-terminated strings\&. Also, static buffers
should not have the Ptr suffix, as in this case:
.CS


   char buf[32];

.CE
.IP
It is recommended that the names of variables of type Tcl_Objs end
with Obj\&.
.IP [4]
Variables that hold address of procedures should have names ending
in Proc, as should typedefs for such variables\&.
.CS


   typedef int (Ns_ModuleInitProc) (const char *server, const char *module);

.CE
.IP [5]
\fI#define\fR macros and constants should be in all
uppercase\&. Underscores separate multiple words (as in NS_TRUE)\&.
.IP [6]
Tcl commands are always in all-lowercase\&.
.PP
.SH "FUNCTION NAMES CONTAIN MEANING"
Public exported functions that are part of the API should begin with
Ns_, as in:
.CS


   extern int Ns_ConnPort(const Ns_Conn *conn)

.CE
.PP
Functions that are to be used by other files in a module, but are
not meant to be called from outside the module, should begin with Ns,
as in:
.CS


   extern void NsDbInit(void);

.CE
.PP
Global variables that do \fInot\fR have static scope begin with ns, as in:
.CS


   ns_Cache *nsAdpCachePtr = NULL;

.CE
.PP
C implementations of Tcl commands should be ending with Cmd, as in:
.CS


   int NsTclSetObjCmd(ClientData arg, Tcl_Interp *interp, int objc, Tcl_Obj *CONST* objv);

.CE
.SH "LOW-LEVEL CODING CONVENTIONS"
If you use Emacs, the following lisp (which you can put in your
\&.emacs file) will make C-mode do much of the formatting for you (its
default behavior is almost correct--this just makes indents be four
spaces):
.CS


   (add-hook 'c-mode-hook
   	(function (lambda ()
   		(setq c-basic-offset 4)
   		(setq c-indent-level 4))))

.CE
Try to follow these rules:
.IP \(bu
Indents are four spaces
.IP \(bu
Code comments occupy full lines, with empty lines before and
after, as such:
.CS


   foo();

   /*
    * This is a comment\&.
    */

   bar();

.CE
.IP \(bu
Opening curly braces go at the end of a line, except for the
beginnings of functions, as such:
.CS


   if (x == y) {
       FooBar();
   }

.CE
.IP
and
.CS


   static void
   FooBar(void)
   {
      Foo();
   }

.CE
.IP \(bu
Always put a blank line after variable definitions:
.CS


   static void
   FooBar(void)
   {
       int blah;

       \&.\&.\&.
       if (blah != 0) {
           char *string;

   	   \&.\&.\&.
       }
   }

.CE
.IP \(bu
Use curly braces even if you don't have to, such as in if
statements that have only statement in the block\&. There is an
exception to this, which is else if clauses which may look like
this:
.CS


   if (!strcmp(cmd, "put")) {
       \&.\&.\&.
   } else if (!strcmp(cmd, "get")) {
       \&.\&.\&.
   } else if (!strcmp(cmd, "reset")) {
       \&.\&.\&.
   } else {
       \&.\&.\&.
   }

.CE
.IP \(bu
No line should exceed 79 characters\&.
.IP \(bu
Labels are indented four spaces fewer than statements, except when
they would touch the left margin, in which case they are indented one
space in from the left margin\&.
.IP \(bu
Switch statements should look like this:
.CS


   switch (adPtr->exception) {
   case ADP_OK:
       exception = "ok";
       break;

   case ADP_BREAK:
       exception = "break";
       break;
   \&.\&.\&.
   }

.CE
.IP \(bu
Avoid macros except for extremely simple operations\&. Enclose
arguments in parentheses, as well as the entire macro
expression:
.CS


   #define MIN(a,b) (((a) < (b)) ? (a) : (b))

.CE
.IP \(bu
Do not use bit fields
.IP \(bu
Goto statements may be used as long as they jump to the end of a
function that then performs cleanup and returns\&. They are an excellent
way of ensuring that functions have only one exit point\&. Most other
uses of goto are, as usual, looked on with disdain\&.
.IP \(bu
Common sense applies when using obscure or confusing parts of the
C language\&. For example, don't do this:
.CS


    if (++c != NULL) {
       foo();
   }

.CE
.IP \(bu
Where it is sensible, have only one return statement in each function\&.
.IP \(bu
Complex if statements (such as those with three or more expressions)
should have newline breaks after the operator separating each expression\&.
In this case, put a newline after the open brace to separate the
conditions from the code that follows\&.
.CS


    if (foo == bar &&
        baz == spoo &&
       ns_FooBarBaz() == NS_TRUE) {

       \&.\&.\&.
   }

.CE
.IP \(bu
When there are multiple variables defined in a block, the first letter
of each variable name should line up, with asterisks running to the left\&.
There should not be multiple variables defined on the same line unless the
relationship between them is obvious\&. Non-obvious variables may be
commented to the right\&.
.sp
The leftmost asterisk should begin on the column that is one space
after the rightmost character of the longest type name\&. If there are no
pointers, then every variable name should begin on the column that is one space
after the rightmost character of the longest type name\&.
.CS


    void
    Foo(void)
   {
       int              bar;
       unsigned int    *fooPtr;
       int          ****extremePtrPtrPtrPtr;  /* Just an example! */

       \&.\&.\&.

.CE
.IP
or
.CS


    void
    Foo(void)
   {
       int          bar;
       unsigned int foo;
       char         baz;

       \&.\&.\&.

.CE
.IP
Variable initializers should not be anything more complex than a constant;
function calls and complicated expressions deserve their own lines of code\&.
.IP \(bu
In pointer definitions, be they local variables,
global variables, parameters, or static functions prototypes,
the asterisk should always make
contact with the first character of the symbol\&. In typecasts, there should
be one space between the type name and the asterisk, and parentheses should
make contact with both:
.CS


    static void *Foo(int *fooPtr);
    int *fooPtr = (int *) barPtr;

.CE
.IP \(bu
If a function ends with a return statement which is neither the only
statement in the function body and is not preceded by a label, an empty
line should appear before it:
.CS


 static int
    Foo(void)
   {
       \&.\&.\&.
       FooBar();

       return code;
   }

.CE
.PP
.SH "IDIOMS, CANONICAL FORMS, AND RECOMMENDED PRACTICES"
The following conventions are frequently used in NaviServer\&. They
are the recommended way of implementing a behavior\&.
.IP \(bu
Configuration parameters should be defined at the top of source files, as
such:
.CS


   #define CONFIG_CACHE "Cache"     /* Enable caching in this module? */
   #define CONFIG_FOO   "Foo"       /* What is foo? */

   #define DEFAULT_CACHE NS_TRUE    /* Caching is on */
   #define DEFAULT_FOO   "Bar"      /* Foo is bar */

.CE
.IP \(bu
C is not PL/I\&. Write this:
.CS


    return foo;

.CE
.IP
not
.CS


    return (foo);

.CE
.IP
With very complicated expressions, parentheses are acceptable:
.CS


    return (sqrt(variance) + foo() / bar() - (MAGIC + getch()) % 99);

.CE
.IP \(bu
Booleans can only have two values: \fBNS_TRUE\fR and \fBNS_FALSE\fR\&.
Using 0 and 1 as boolean values is discouraged\&. Also avoid using the
conventions of
.CS


    if (foo) { \&.\&.\&. }

.CE
.IP
and
.CS


    if (!foo) { \&.\&.\&. }

.CE
.IP
rather, say:
.CS


    if (foo == NS_TRUE) {
       \&.\&.\&.
   }

.CE
.IP
or
.CS


    if (foo == NS_FALSE) {
       \&.\&.\&.
   }

.CE
.IP
Of course, this only applies to NaviServer APIs and internal boolean values\&.
Respect the wishes of library calls; values from outside code should never
be compared with \fBNS_TRUE\fR or \fBNS_FALSE\fR, nor should
\fBNS_TRUE\fR or \fBNS_FALSE\fR values
ever be passed to outside code\&.
.IP \(bu
Explicit checks for null values are usually preferred over implicit checks\&.
.sp
For pointers, use \fBNULL\fR:
.CS


   if (fooPtr == NULL) {
       \&.\&.\&.
   }

.CE
.IP
or
.CS


   if (fooPtr != NULL) {
       \&.\&.\&.
   }

.CE
.IP
For characters, use \fB'\\0'\fR when checking for equality to zero:
.CS


    if (char == '\\0') {
       \&.\&.\&.
   }

.CE
.IP
For integers, explicitly use \fB0\fR when checking for equality to zero:
.CS


    if (foo == 0) {
       \&.\&.\&.
   }

.CE
.PP
