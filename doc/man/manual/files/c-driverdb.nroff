'\"
'\" Generated from file 'c-driverdb\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "c-driverdb" n 4\&.99\&.19 manual "NaviServer Manual"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
c-driverdb \- NaviServer Database Driver Development Guide
.SH DESCRIPTION
.SH INTRODUCTION
.PP
A database driver is a module that interfaces between the NaviServer
database-independent nsdb API and the API of a particular DBMS\&. A
database driver provides implementations of a standard set of
functions for doing such things as opening connections to the
database, sending SQL statements, returning results to a standard
form, and closing connections\&. NaviServer takes care of managing
collections of open database connections called database pools\&.
.PP
Database driver modules look much like ordinary NaviServer modules but
are loaded differently\&. Instead of being listed with other modules in
the ns/server/server-name/modules section of the configuration file, a
database driver is listed in the ns/db/drivers section -- a database
driver is not tied to a particular virtual server\&. The database driver
initialization function must call ns_DbRegisterDriver() with an array
of pointers to functions\&. These functions are then later used by
NaviServer to perform database operations\&. The virtual server
initialization function is called each time nsdb is loaded into a
virtual server\&. The server initialization function
(ns_dbms-nameServerInit) adds the Tcl command ns_dbms-name to the
server's Tcl interpreters\&. The ns_dbms-name command can then be used
to fetch driver-specific information about an active connection\&.
.PP
NOTE: The above naming scheme is simply based on convention\&. It is not
enforced, and can be changed at the programmer's discretion\&.
.PP
.SH "INTERNAL VS\&. EXTERNAL DATABASE DRIVERS"
.PP
Before developing a database driver, you need to decide whether the
driver will be internal or external:
.PP
.IP \(bu
Internal: An internal driver is tightly coupled with the
NaviServer; the database client libraries are linked directly into
the server\&.
.sp
.IP \(bu
External: An external driver is loosely coupled; the nsext driver
sends messages to an external database proxy daemon instead of
calling the database client libraries directly\&. This database
proxy daemon can be a local or remote process\&.
.PP
.PP
While an internal driver can be faster and can use less resources than
an external driver, there are several reasons to develop an external
driver:
.PP
.IP \(bu
Many database client libraries are not thread-safe -- you'll need
to be very careful about locking the libraries to use them in an
internal driver, and this can unnecessarily slow down simultaneous
queries\&.
.sp
.IP \(bu
Many database client libraries make assumptions regarding
per-process resources such as signals\&.
.sp
.IP \(bu
An external driver can be used to access a database from a
platform that may not be supported by the database client library\&.
.PP
.PP
.SH "THE INTERNAL DRIVER API"
.PP
The set of function points that a database driver implements and what
NaviServer expects is as follows:
.IP [1]
Name
.IP [2]
Database type
.IP [3]
Server initialization
.IP [4]
Open a database connection
.IP [5]
Close a database connection
.IP [6]
Get row from table
.IP [7]
Flush
.IP [8]
Cancel a database connection
.IP [9]
Get information about a table
.IP [10]
Get list of tables
.IP [11]
Best row identifier (identifies each row uniquely)
.IP [12]
Execute SQL query
.IP [13]
Optional: Reset a database handle when it gets checked back into
the pool\&.
.PP
.PP
The database driver's job is to make the appropriate DBMS-specific
function calls that will implement these functions\&. The driver must
provide an implementation of the function ns_DbDriverInit; This
function is executed once, when the server starts up\&. The most
important thing it does is call ns_DbRegisterDriver with an array of
all the functions implemented by the driver\&. Here's an example from
the Postgres95 db driver:
.CS




static ns_DbProc PgProcs = {
    {DbFn_Name, (void *) ns_PgName},
    {DbFn_DbType, (void *) ns_PgDbType},
    {DbFn_OpenDb, (void *) ns_PgOpenDb},
    {DbFn_CloseDb, (void *) ns_PgCloseDb},
    {DbFn_DML, (void *) ns_PgCmd},
    {DbFn_Select, (void *) ns_PgSelect},
    {DbFn_GetRow, (void *) ns_PgGetRow},
    {DbFn_Flush, (void *) ns_PgFlush},
    {DbFn_Cancel, (void *) ns_PgFlush},
    {DbFn_GetTableInfo, (void *) ns_PgGetTableInfo},
    {DbFn_TableList, (void *) ns_PgTableList},
    {DbFn_BestRowId, (void *) ns_PgBestRowId},
    {DbFn_ServerInit, (void *) ns_PgServerInit},
    {DbFn_ResetHandle, (void *) NULL},
    {0, NULL}
};

DllExport int
ns_DbDriverInit(char *hDriver, char *configPath)
{
    /*
     * Register the Postgres95 driver functions with nsdb\&.
     * Nsdb will later call the ns_PgServerInit() function
     * for each virtual server which utilizes nsdb\&.
     */
    if (ns_DbRegisterDriver(hDriver, &(PgProcs[0])) != NS_OK) {
        ns_Log(Error, "ns_DbDriverInit(%s):  Could not register the %s driver\&.",
            hDriver, pgName);
        return NS_ERROR;
    }
    ns_Log(Notice, "%s loaded\&.", pgName);
    return NS_OK;
}


.CE
.PP
In more detail, here's what each of these functions needs to do:
.PP
.IP [1]
char *ns_dbms-nameName(ns_DbHandle *handle);
.sp
This function returns the string which identifies the database
driver\&.
.sp
.IP [2]
char *ns_dbms-nameDbType(ns_DbHandle *handle);
.sp
This function returns the string which identifies the database
type\&. Usually it is the same as the name of the driver\&.
.sp
.IP [3]
int ns_dbms-nameServerInit(char *hServer, char *hModule, char
*hDriver);
.sp
ns_dbms-nameServerInit calls another function named
ns_dbms_nameInterpInit which is responsible for adding
the command ns_dbms-name to a single Tcl interpreter\&.
ns_dbms-nameServerInit calls ns_dbms-nameInterpInit for
each interpreter in the virtual server that is being
initialized\&.
.sp
.IP [4]
int ns_dbms-nameOpenDb(ns_DbHandle *dbh);
.sp
This function takes a pointer (typically known as the "handle")
to the ns_DbHandle structure as an argument\&. The handle
contains information such as the driver name, name of the
datasource, user name and password, name of the database
pool and some other parameters\&. The structure is as
follows:
.sp
.CS



typedef struct ns_DbHandle {
    char       *driver;
    char       *datasource;
    char       *user;
    char       *password;
    void       *connection;
    char       *poolname;  /* poolname associated for this handle */
                           /* used by internal DbAPI */
    int         connected;
    int         verbose;   /* used for verbose error messages */
                           /* equivalent to [ns/db/pool/poolname] Verbose=On */
                           /* used by internal Db API */
    ns_Set     *row;       /* used for row data during binds, getrows, etc\&.*/
                           /* used by internal Db API */
    char        cExceptionCode[6];
    ns_DString  dsExceptionMsg;
    void       *context;
    void       *statement; /* used by ODBC driver statements */
    int         fetchingRows;
} ns_DbHandle;


.CE
.sp
The statement field is used as a pointer to your allocated
statement handles (hstmt)\&. It can be used to pass a
DbHandle with a pointer to the statement handle to other
driver functions to invoke cancels (e\&.g\&., SQLCancel())
and error reporting (e\&.g\&., SQLError())\&.
.sp
This function takes the information contained in the handle and
opens a connection to the database named in the handle
along with the username and password\&. If a connection is
successfully established, then OpenDb performs some
database specific functions, and returns NS_OK\&. If it is
unable to establish a connection to the database server,
or if it is unable to perform the required database
specific functions, it returns NS_ERROR\&. The status is
logged by using the ns_Log function\&.
.sp
Note: For more information about database-specific functions, the
documentation about its API should be consulted\&.
.sp
.IP [5]
int ns_dbms-nameCloseDb(ns_DbHandle *handle);
.sp
This function takes a handle as an argument and terminates the
connection to the database server\&. It also cleans up the
handle parameters\&. It returns with either NS_OK or
NS_ERROR (in case CloseDb fails to close the connection)\&.
.sp
.IP [6]
int ns_dbms-nameGetRow(ns_DbHandle *handle, ns_Set *row);
.sp
The results of a SELECT query are usually a number of rows\&.
ns_dbms-nameGetRow is responsible to obtain these rows
from the database and return them to NaviServer for
display/manipulation\&. This function typically does the
following:
.sp
checks if it is being called from within a fetch row loop
checks if the end of data is reached, and if so, stops
returns the next row in the result set
.sp
You can return the values something like this:
.sp
ns_SetPutValue(row, (int) i, colval);
.sp
This function should return either NS_ERROR or NS_OK\&.
.sp
.IP [7]
int ns_dbms-nameFlush(ns_DbHandle *handle);
.sp
This function flushes any rows which are waiting to be retrieved
after a SELECT is executed\&. The rows are irretrievably
lost\&. The fields for columns, tuples, and current tuple
in the connection structure are reset to 0\&. The result
field is reset to NULL\&. This function should return
either NS_ERROR or NS_OK\&.
.sp
.IP [8]
int ns_dbms-nameCancel(ns_DbHandle *handle);
.sp
A call to this function results in cancelling that particular
database connection\&.
.sp
.IP [9]
ns_DbTableInfo *ns_dbms-nameGetTableInfo(ns_DbHandle *handle, char
*table, int fExtended);
.sp
This function returns table-specific information such as number
of attributes in the table, their types etc\&. The third
parameter is for internal use and can be ignored\&.
ns_DbTableInfo is a array of ns_Set * and the sets
contain something resembling the following:
.sp
.CS



    set->name           = "column_name";
    set->field[0]\&.name  = "column_type";
    set->field[0]\&.value = "text";
    set->field[1]\&.name  = "column_notnull";
    set->field[1]\&.value = "t";


.CE
.sp
A "t" or an "f" would represent whether the column is nullable or
not\&.
.sp
.IP [10]
char *ns_dbms-nameTableList(ns_DString *pds, ns_DbHandle *handle,
int includesystem);
.sp
This function builds a database-specific SELECT statement which
returns a list of all tables in the database\&. The
function returns this list\&. In case of a NULL table name,
a warning is logged by ns_Log\&. The list of tables should
be returned in the pds parameter in the form
"string\\0string\\0string\\0", which can be implemented as
follows:
.sp
ns_DStringNAppend(pds, table, strlen(table) +1);
.sp
.IP [11]
char *ns_dbms-nameBestRowId(ns_DString *pds, ns_DbHandle *handle,
char *table);
.sp
This function returns the unique identifier for a table\&. In most
cases, it is usually the primary key for the table\&. In
some cases, the system table containing table information
contains a unique identifier for each table\&. In such
cases, this identifier is returned\&. The pds parameter is
an initialized ns_DString that gets the primary key
(e\&.g\&., in Postgres, ns_DStringNAppend(pds, "oid", 4))\&.
.sp
.IP [12]
int ns_dbms-nameExec(ns_DbHandle *handle, char *sql);
.sp
This function takes an SQL command and sends it to the DBMS\&. If
the command is returns rows, the function should return
NS_ROWS\&. If the command was DDL or DML, then the function
should return NS_DML\&. And of course if there is an error
executing the SQL, the function should return NS_ERROR\&.
It is recommended that you define one ns_dbms-nameExec
procedure that handles both queries that return rows and
those that do not\&. When ns_DbExec is invoked in
NaviServer, it calls whatever ns_DbExec function is
defined\&. When ns_DbSelect is invoked, it tries ns_DbExec
first and then ns_DbSelect\&.
.sp
.IP [13]
int ns_dbms-nameResetHandle(ns_DbHandle *handle);
.sp
This function will be called with the database handle every time
one is returned to the database pool\&. You can use this to
normalize it's state for the next use; for example always
setting the handle to autocommit mode and aborting any
uncommitted transactions\&.
.PP
.PP
.SH "THE EXTERNAL DRIVER API"
.PP
To build an external driver, you need to provide implementations for
several functions, and then link your code with the provided
\'nspdmain' program, found in the nspd\&.a library\&. The resulting
"database proxy daemon" is contacted by the server's "external" driver
(the client in the following descriptions) for all database
activities\&. The 'nspdmain' program handles all communication with the
server's 'external' driver, calling your routines database-specific
functions\&. Note that there is a single database proxy daemon
associated with each database connection, so all of the state for each
connection is encapsulated here\&. Database connections are managed
efficiently by the server's database pool mechanism\&.
.PP
The next section summarizes the External Driver Proxy Daemon
functions\&. The reference section at the end of this appendix describes
each function in detail and gives a pseudo-code implementation\&. Each
implementation of a function may be a different for each
dbms-specification\&. Consult your database client library documentation
and the freely distributed NaviServer examples of the Sybase Proxy
daemons for more information and dbms-specific examples\&.
.PP
.SS "FUNCTIONS TO BE IMPLEMENTED"
.PP
The set of functions that need to be implemented are:
.PP
.IP [1]
void *ns_PdDbInit (void)
.sp
This function is called once from the 'nspdmain' when the
database driver is initialized at process startup\&. It
normally allocates and returns a dbms-specific structure
to be passed to all other routines\&. It also calls any
dbms-specific initialization routines\&. This function does
not open a connection to the database\&.
.sp
.IP [2]
void ns_PdDbCleanup(void *handle)
.sp
This function is called once from the 'nspdmain' when the
database driver is initialized at process startup\&. It
performs cleanup associated with process shutdown and
frees the database-specific handle\&.
.sp
.IP [3]
void ns_PdDbOpen(void *handle, char *openArgs)
.sp
This function opens a connection to the database based on the
openArgs passed in\&. The handle passed in is the handle
that was returned by ns_PdDbInit, and will usually be
cast to some driver-specific data structure\&. If the open
operation is successful, this function should call
ns_PdSendString with OK_STATUS\&. On failure, the function
should use ns_PdSendString to return an error string\&.
.sp
.IP [4]
void ns_PdDbClose(void *handle)
.sp
This function closes the database\&. It should not free the
database handle\&. If the close operation is successful,
this function should call ns_PdSendString with OK_STATUS\&.
On failure, the function should use ns_PdSendString to
return an error string\&.
.sp
.IP [5]
void ns_PdDbExec(void *handle, char *sql)
.sp
This function executes a SQL query\&. If the SQL is executed
successfully, this function should call ns_PdSendString
with OK_STATUS followed by either
ns_PdSendString(EXEC_RET_ROWS) or
ns_PdSendString(EXEC_RET_DML), depending on whether the
SQL returned rows or was a DML statement\&. On failure, the
function should use ns_PdSendException to return an
error\&.
.sp
.IP [6]
void ns_PdDbFlush(void *handle)
.sp
Flushes any pending data\&. Usually this function will call
ns_PdDbCancel or something similar along with any other
database specific clean-up routines\&. If the flush
operation is successful, this function should call
ns_PdSendString with an OK_STATUS\&. On failure, the
function should use ns_PdSendString to return an error
string\&.
.sp
.IP [7]
void ns_PdDbCancel(void *handle)
.sp
This function cancels the current database operation\&. If the
cancel operation was successful, this function should
call ns_PdSendString with OK_STATUS\&. On failure, the
function should use ns_PdSendString to return an error
string\&.
.sp
.IP [8]
void ns_PdDbBindRow (void *handle)
.sp
This function should retrieve from the DBMS a list of column
names of rows and return this data to the client\&. If the
bind-row operation is successful, this function should
call ns_PdSendString with an OK_STATUS\&. On failure this
function should return an exception code with
ns_PdSendException\&.
.sp
.IP [9]
void ns_PdDbGetRow(void *handle, char *columnCount)
.sp
This function should retrieve from the DBMS the row associated
with the columnCount column and send this data to the
client\&. If the get-row operation was successful, this
function should call ns_PdSendString with an OK_STATUS
and then send the data with ns_PdDbSendData\&. On failure,
the function should use ns_PdSendException to return an
error\&.
.sp
.IP [10]
void ns_PdDbTableList (void *handle, char *includeSystem)
.sp
This function should retrieve the list of table names from the
database associated with the handle and send this data to
the client\&. The includeSystem parameter indicates whether
to include system tables with this list\&. The function
should implement the following protocol:
.sp
If the initial SQL query returns a successful status of DB_ROWS
when generating the table names, then this function
should:
.sp
.RS
.IP [1]
Call ns_PdSendString with an OK_STATUS\&.
.sp
.IP [2]
Call ns_PdSendString with a size of the item (table name)\&.
.sp
.IP [3]
Call ns_PdSendData to send the actual data associated with
the name and to signal the end of data\&.
.sp
.IP [4]
If an exception occurs during the processing of the table
data, then this function should send the partial data to the
client and indicate an error with ns_PdDbLog\&.
.RE
.sp
If an exception is raised before successfully retrieving some of
the table data, then this function should call
ns_PdSendException to return an error\&.
.sp
.IP [11]
void ns_PdDbGetTableInfo(void *handle, char *tableName)
.sp
This function should retrieve the system catalog information
(columns, types, etc\&.) about a table and send this to the
client\&.
.sp
If the initial SQL select query returns a successful status of
DB_ROWS, then this function should:
.sp
.RS
.IP [1]
Call ns_PdSendString with an OK_STATUS\&.
.sp
.IP [2]
Call ns_PdSendRowInfo to send to the client the column info\&.
.sp
.IP [3]
Call ns_PdSendRowInfo to send to the client subsequent row
info\&.
.sp
.IP [4]
Call ns_PdSendData to indicate to the client that END_DATA
has been reached\&.
.sp
.IP [5]
If an exception occurs during the processing of the row info,
then this function should send the partial data to the client
and indicate an error with ns_PdDbLog\&.
.RE
.sp
If an exception is raised before successfully retrieving some of
the row info, then this function should call
ns_PdSendException to return an error\&.
.sp
.IP [12]
void ns_PdDbBestRowId(void *handle, char *tableName)
.sp
This function retrieves the primary key of a table from the
database and sends this to the client\&. If a table has a
primary key, NaviServer can perform row updates and
deletes\&. If the best-row-id operation is successful, this
function should call ns_PdSendString with an OK_STATUS\&.
If a best-row-id is found then call ns_PdSendString with
the column name; otherwise, call ns_PdSendString with
NO_BESTROWID\&. On failure this function should return an
exception code with ns_PdSendException\&.
.sp
.IP [13]
void ns_PdDbIndentify(void *handle)
.sp
This function sends a string identifying the proxy daemon name
and version with ns_PdSendString\&.
.sp
.IP [14]
void ns_PdDbGetTypes(void *handle)
.sp
This function sends a string of the data types for the database
with ns_PdSendString\&.
.sp
.IP [15]
void ns_PdDbResultId(void *handle)
.sp
This function sends to the client with ns_PdSendString the id of
the last object affected by an exec command or a null
terminated string\&.
.sp
.IP [16]
void ns_PdDbResultRows(void *handle)
.sp
This function sends to the client with ns_PdSendString the number
of rows affected by last exec command\&.
.sp
.IP [17]
void ns_PdDbSetMaxRows(void *handle, char *maxRows)
.sp
This function sets the max rows for the database\&. If this
function is successful or the SQL command is undefined
for your specific DBMS, it should call ns_PdSendString
with an OK_STATUS\&. If set-max-rows is defined for your
specific DBMS and there is an exception raised, then this
function should send an exception code with
ns_PdSendException\&.
.sp
.IP [18]
void ns_PdDbSpExec(void *handle)
.sp
This function executes a stored procedure that has been
initialized with ns_PdDbSpStart and ns_PdDbSpSetParam\&.
.sp
.IP [19]
void ns_PdDbSpGetParams(void *handle)
.sp
This function returns output parameters from a previously
executed stored procedure\&.
.sp
.IP [20]
void ns_PdDbSpReturnCode (void *handle)
.sp
This function gets the return code from a previously executed
stored procedure\&.
.sp
.IP [21]
void ns_PdDbSpSetParam (void *handle, char *args)
.sp
This function sets parameters in a stored procedure before
executing it\&.
.sp
.IP [22]
void ns_PdDbSpStart(void *handle, char *procname)
.sp
This function begins the definition of a stored procedure\&.
.PP
.PP
.SS "UTILITY FUNCTIONS"
.PP
In implementing the above functions, you will need to call some of the
various utility functions described below\&. When using these functions,
do not pass a parameter of NULL for string values\&. If you do, an error
message is printed to the syslog and the function returns\&.
.PP
.IP [1]
void ns_PdLog(ns_PdLogMsgType errtype, char *fmt, \&.\&.\&.)
.sp
The ns_PdLog function sends a formatted messages to the client\&.
Allowable values for the log type are the following with
a default type of Error: Notice, Trace, Error\&.
.sp
.IP [2]
void ns_PdSendString(char *string)
.sp
This function sends a string to the client\&.
.sp
.IP [3]
void ns_PdSendException(char *code, char *msg)
.sp
The command sends an exception code and an exception message to the
client\&.
.sp
.IP [4]
ns_PdParseOpenArgs(char *openargs, char **datasource, char **user,
char **password, char **param)
.sp
This function parses the datasource, user, password, and param
parameters leaving missing elements as NULL\&. This
function is normally called from within ns_PdDbOpen\&.
.sp
.IP [5]
void ns_PdSendRowInfo(ns_PdRowInfo * rowInfo)
.sp
This function sends a row encapsulated in an ns_PdRowInfo
structure to the client\&.
.sp
.IP [6]
void ns_PdSendData(char *data, int len)
.sp
This function sends data of length len to the client\&. You
indicate that you are finished sending data by calling
this function with END_DATA\&.
.sp
.IP [7]
void ns_PdFreeRowInfo(ns_PdRowInfo * rowInfo, int fFreeData)
.sp
This function frees a ns_PdRowInfo data structure\&. If fFreeData
is a non-zero value, then this function frees the data
associated with the ns_PdRowData structure (encapsulated
in ns_PdRowInfo) as well\&.
.PP
.PP
.SS CONSTANTS
.PP
The following constants are used in the example drivers:
.PP
#define EXCEPTION_CODE_MAX 32
.PP
#define EXCEPTION_MSG_MAX 4096
.PP
These constants are used for the buffer sizes for the database
error/exception code and error/exception message, respectively\&. The
given buffer size must include a terminating null byte\&. In other
words, you can have an exception message of up to 4095 bytes,
reserving the last byte for a null byte\&.