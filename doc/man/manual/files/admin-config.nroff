'\"
'\" Generated from file 'admin-config\&.man' by tcllib/doctools with format 'nroff'
'\"
.TH "admin-config" n 4\&.99\&.23 manual "NaviServer Manual"
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.BS
.SH NAME
admin-config \- NaviServer Configuration Reference
.SH DESCRIPTION
When NaviServer is started, typically a configuration file is provided
providing certain settings for the server\&. The configuration file
includes network configuration options, log file information, loading
of modules and database drivers and the like\&. Actually, the
configuration file can contain the definition of multiple servers,
running concurrently or depending on command line arguments also
separately (see \fIadmin-maintenance\fR)\&.
.PP
The NaviServer configuration file consists of multiple sections
containing global configuration of the instance and sections for each
server and module\&. The configuration file is actually a Tcl script,
such that at user can set variables, defined procs to avoid repeated
patterns and the like\&. Tcl variables are typically used to certain
parameters at the begin of the file, which might be often
changed\&. This eases the maintenance\&.
.PP
The following sample configuration files might be used as a
starting point for site specific configurations:
Sample documented configuration files:
.IP \(bu
\fIsimple-config\&.tcl\fR [https://bitbucket\&.org/naviserver/naviserver/raw/default/simple-config\&.tcl]
.IP \(bu
\fInsd-config\&.tcl\fR [https://bitbucket\&.org/naviserver/naviserver/raw/default/nsd-config\&.tcl]
.IP \(bu
\fIopenacs-config\&.tcl\fR [https://bitbucket\&.org/naviserver/naviserver/raw/default/openacs-config\&.tcl]
.PP
Several configuration hints and details can be found also on other
spaces in the manual, such as e\&.g\&. in \fIadmin-tuning\fR or for
module specific parameters (which might not be necessary in every
installation\&. Furthermore, the configuration mechanism of NaviServer
is extensible, therefore, modules and applications can as well
use the configuration file with its abstraction to define application
specific parameters\&. So, a listing of the parameters can never
complete\&. In this page, we primarily define introductory examples
for typical usage scenarios\&.
.PP
The main sections of a configuration file are:
.IP \(bu
Global configuration values
.RS
.IP \(bu
general parameters (starting with "ns/parameters")
.IP \(bu
thread parameters (starting with "ns/threads")
.IP \(bu
mimetypes (starting with "ns/mimetypes")
.IP \(bu
database drivers (starting with "ns/db")
.IP \(bu
global modules (starting with "ns/modules")
.IP \(bu
servers (starting with "ns/servers")
.RE
.sp
Examples for global parameters are in the mentioned
sample configuration files and also e\&.g\&. in \fItcl-libraries\fR
and \fIadmin-tuning\fR\&.
.IP \(bu
Server specific parameters (starting with "ns/server/$server")
.IP \(bu
Module specific parameters (like \fInssock\fR, \fInsssl\fR,
\fInscp\fR, \fInslog\fR, \fInscgi\fR or \fInsperm\fR\&.
.PP
.SH EXAMPLES
In general, when modifying configuration files, it is always a good
idea to check whether a configuration file is syntactically correct
before starting the server\&. This can reduce the downtime of a
production server in case of typos\&. A configuration file named
"nsd-config\&.tcl" can be checked with the command line option \fI-T\fR
of NaviServer\&.
.CS


 /usr/local/ns/bin/nsd -t nsd-config\&.tcl -T

.CE
The global parameters contain the basic setup information,
where for example the root of the root of nsd is, where the
server log is to be written, or whether the server runs behind
a proxy server or not\&.
.CS


 ns_section ns/parameters {
   ns_param home             /var/www/myserver/
   ns_param tcllibrary       tcl
   ns_param serverlog        error\&.log
   # \&.\&.\&.
   ns_param reverseproxymode true
 }

.CE
When reverse proxy mode is turned on, the server assumes it is running
behind a reverse proxy server\&. In this case, commands referring to the
client IP address will return on default the value as provided by the
reverse proxy server (i\&.e\&. provided via the x-forwarded-for header
field)\&. This will effect the results of \fBns_conn peeraddr\fR
and various introspection commands\&.
.PP
Below we address some general design consideration when
tailoring your one configuration files\&.  Check for simple or real-live
setups of larger installations by the provided sample configuration
files\&.
.PP
One of the core components of the configuration file are the network
drivers: what protocols should be used, on which addresses/ports
should be used, or how to set up virtual servers\&. The most important
network drivers of NaviServer are \fInssock\fR and
\fInsssl\fR\&.
.PP
Several additional network drivers are available via
extra modules, such as e\&.g\&. \fInsudp\fR, \fInssmtpd\fR
(for a full list of modules, see the \fImodule repository\fR [https://bitbucket\&.org/naviserver/workspace/projects/PROJ])\&.
.SS "SINGLE SERVER, SINGLE ADDRESS, SINGLE PORT"
In the simplest case, one defines in a configuration file a single
server \fIs1\fR with single network driver \fInssock\fR\&. In the
example below the server is listening on port 8000\&.
.CS


 ns_section ns/servers {
   ns_param s1 "Server Instance 1"
 }

 ns_section ns/server/s1/modules {
   ns_param nssock  nssock\&.so
 }

 ns_section ns/server/s1/module/nssock {
   ns_param address 0\&.0\&.0\&.0
   ns_param port    8000
 }

.CE
In this example, the module is loaded for the server "s1"\&. We show in
later examples, how to load a network driver globally, such that one
network driver can be used for multiple servers\&.
.SS "MULTIPLE ALTERNATIVE SERVERS IN ONE CONFIGURATION FILE"
It is as well possible to define multiple servers in the same
configuration file (here \fIs1\fR and \fIs2\fR)\&. These servers
use the same driver \fInsock\fR but with different ports\&.
In this case it is sufficient to load the driver once\&.
.CS


 ns_section ns/servers {
   ns_param s1     "Server Instance 1"
   ns_param s2     "Server Instance 1"
 }

 #
 # Server s1
 #
 ns_section ns/server/s1/modules {
   ns_param nssock  nssock\&.so
 }

 ns_section ns/server/s1/module/nssock {
   ns_param address  0\&.0\&.0\&.0
   ns_param port     8000
 }

 #
 # Server s2
 #
 ns_section ns/server/s2/modules {
   ns_param nssock   nssock\&.so
 }

 ns_section ns/server/s2/module/nssock {
   ns_param address  0\&.0\&.0\&.0
   ns_param port     8001
 }

.CE
When the configuration file above is named e\&.g\&. two-server-config\&.tcl,
the two servers can be started with a command line like:
.CS


 /usr/local/ns/bin/nsd -u nsadmin -t two-server-config\&.tcl -f

.CE
When it is the goal to start only one of these servers, one can use
e\&.g\&. the following command:
.CS


/usr/local/ns/bin/nsd -u nsadmin -t two-server-config\&.tcl -f -server s2

.CE
.SS "SINGLE SERVER LISTENING ON MULTIPLE IP ADDRESSES"
Often, a server has the requirement to listen on multiple addresses,
such as on one (or many) IPv4 and one (or many) IPv6 addresses\&.
This can be addressed by simply providing the list of values as
a parameter value\&.
.CS


 ns_section ns/servers {
   ns_param s1 "Server Instance 1"
 }

 ns_section ns/server/s1/modules {
   ns_param nssock  nssock\&.so
 }

 ns_section ns/server/s1/module/nssock {
   ns_param address {137\&.208\&.116\&.31 2001:628:404:74::31}
   ns_param port    8000
 }

.CE
.SS "SINGLE SERVER LISTENING ON MULTIPLE PORTS"
Similarly, we can define a single server, listening on multiple
ports\&. In this case, one can load multiple instances of the driver
where each of the driver listens on a different port\&. In the following
example we name the different instances of the network driver
\fInssock1\fR and \fInssock2\fR\&.
.CS


 #
 # Server s1, using listening on two ports
 #
 ns_section ns/server/s1/modules {
   ns_param   nssock   nssock\&.so
 }

 ns_section ns/server/s1/module/nssock {
   ns_param address   0\&.0\&.0\&.0
   ns_param port      "8000 8001"
 }

.CE
When multiple IP addresses and multiple ports are specified, the
server will be listening for every specified address on every
specified port\&. In the following example, it will listen on four
different combinations of addresses and ports\&.
.CS


 ns_section ns/server/s1/module/nssock {
   ns_param address {137\&.208\&.116\&.31 2001:628:404:74::31}
   ns_param port    "8000 8001"
 }

.CE
.SS "SINGLE SERVER REGISTERING ON MULTIPLE DRIVERS"
In the last two examples a single server is listening on different
ports and or IP addresses but the configuration of the driver was
otherwise identical\&. In case, different driver parameters are needed
it is possible to load the same driver multiple times for the same
server with different driver names\&.
In the following example we name the different instances of the
network driver \fInssock1\fR and \fInssock2\fR\&.
.CS


 #
 # Server s1, using two drivers for listening on two ports on two
 # different addresses\&.
 #
 ns_section ns/server/s1/modules {
   ns_param nssock1   nssock\&.so
   ns_param nssock2   nssock\&.so
 }

 ns_section ns/server/s1/module/nssock1 {
   ns_param address   0\&.0\&.0\&.0
   ns_param port      8000
 }

 ns_section ns/server/s1/module/nssock2 {
   ns_param address   127\&.0\&.0\&.1
   ns_param port      8001
 }

.CE
It would be as well possible to register multiple addresses for every
network driver instance (here "nssock1" and "nssock2")\&. In general, by
loading a network driver multiple times, all the of parameters of the
driver modules (here \fInssock\fR) can be modified per driver
instance\&.
.SS "VIRTUAL SERVERS"
By using virtual servers, multiple different server configurations can
be used while using only a single IP address/port combination\&. The
main different between a virtual server and the case of defining
multiple alternative servers above is that the servers are available
concurrently\&. The server determines by the "Host:" header field
provided by the client to which server the request should be routed\&.
Using such virtual servers is a common technique, where e\&.g\&. for the
same IP address, multiple DNS names are registered\&. According to
HTTP/1\&.1, clients have to send the hostname in the host header field
to the server, such that the server can behave differently depending
on contents of this field\&.
.PP
In the following example, we define two web servers "s1" and "s2",
which should act as virtual servers\&. This means, we want to define one
network driver, which listens on a single port, but which should
direct requests to the server based on the content of the \fIhost\fR
header field\&.
.PP
Assume for the IP address of the server the DNS names
\fIfoo\&.com\fR, \fIbar\&.com\fR and \fIbaz\&.com\fR are registered\&. We define
server "s1" and "s2" such that "s1" should receive requests from
\fIfoo\&.com\fR, and "s2" should receive requests from \fIbar\&.com\fR and
\fIbaz\&.com\fR\&. Servers "s1" and "s2" have different \fIpagedir\fR
definitions\&.
.PP
For defining virtual servers, the network driver has to be
loaded globally (i\&.e\&. as module \fBns/module/nssock\fR)\&.  For
requests with missing/invalid host header fields, we have to define a
\fIdefaultserver\fR to handle such requests in the global definition\&.
In the section \fBns/module/nssock/servers\fR we define the mapping
between the hostnames and the defined servers\&. Note that one can
define multiple DNS names also for a single server (here for \fBs2\fR)\&.
.CS


 #
 # Define two servers s1 and d2 as virtual servers
 #
 ns_section ns/servers {
   ns_param s1  "Virtual Server s1"
   ns_param s2  "Virtual Server s2 "
 }
 ns_section ns/server/s1/fastpath {
   ns_param pagedir /var/www/s1
 }
 ns_section ns/server/s2/fastpath {
   ns_param pagedir /var/www/s2
 }

 #
 # Define a global nssock driver,
 # directing requests to the virtual servers
 # based on the "Host:" header field\&.
 #
 # It is necessary to define a "defaultserver"
 # for requests without a "Host:" header field\&.
 #
 ns_section ns/modules {
   ns_param nssock nssock\&.so
 }
 ns_section ns/module/nssock {
   ns_param port          8000
   ns_param defaultserver s1
 }

 #
 # Define the mapping between the DNS names and the servers\&.
 #
 ns_section ns/module/nssock/servers {
   #
   # Domain names for s1
   #
   ns_param s1 foo\&.com

   #
   # Domain names for s2
   #
   ns_param s2 bar\&.com
   ns_param s2 baz\&.com
 }

.CE
.SS "VIRTUAL SERVERS WITH HTTPS"
In general, the logic of the definition of servers and network drivers
is the same for HTTP (\fInssock\fR) and HTTPS (\fInsssl\fR), except
that the latter has some more configuration parameters, such as
e\&.g\&. the certificate, or a special configuration of the ciphers,
etc\&.
.PP
In order to define virtual servers with HTTPS, one can
essentially use the definition of the previous section, and load as
well the nsssl driver globally, and configure it accordingly\&.
.CS


 #
 # Define a global nsssl driver
 #
 ns_section ns/modules {
   ns_param nssock nsssl\&.so
 }

 ns_section ns/module/nsssl {
   ns_param port          8433
   ns_param defaultserver s1
   ns_param certificate   /usr/local/ns/modules/nsssl/server\&.pem
 }

 ns_section ns/module/nsssl/servers {
   ns_param s1 foo\&.com
   ns_param s2 bar\&.com
   ns_param s2 baz\&.com
 }

.CE
However, this case requires that all accepted hostnames are listed in
the certificate\&. Such certificates are called multi-domain SAN
certificates\&.
.PP
However, there might be cases, where a server listening on a
single address has to provide different certificates for
e\&.g\&. "foo\&.com" and "bar\&.com"\&. For virtual hosting this is a
chicken-egg problem: the right certificate is needed at the time the
connection is opened, but  the virtual server can be only detected
while reading the request header\&.
.PP
This is a well-known problem, for which the SNI TLS extension was invented
(a hostname that can be used for identifying the certificate is passed
during the TLS handshake as well)\&.
.SS "VIRTUAL SERVERS WITH HTTPS AND SNI"
In order to configure SNI (Server Name Indication) for HTTPS, one can
simply add additional certificates for the server needed\&.  In the
following example the default certificate is defined on the level of
the global driver (server\&.pem), whereas the certificate for the
server "foo\&.com" (which will be served by "s1") is defined for the
server "s1" separately (foo\&.com\&.pem)\&.
.CS


 #
 # Define a global nsssl driver
 #
 ns_section ns/modules {
   ns_param nssock nsssl\&.so
 }
 ns_section ns/module/nsssl {
   ns_param port          8433
   ns_param defaultserver s1
   ns_param certificate   /usr/local/ns/modules/nsssl/server\&.pem
 }
 ns_section ns/module/nsssl/servers {
   ns_param s1 foo\&.com
   ns_param s2 bar\&.com
   ns_param s2 baz\&.com
 }

 #
 # Define a server-specific certificate to enable SNI\&.
 # Activate for this server as OCSP stapling\&.
 #
 ns_section ns/server/s1/module/nsssl {
   ns_param certificate   /usr/local/ns/modules/nsssl/foo\&.com\&.pem
   ns_param OCSPstapling  on
 }

.CE
More to come here\&.\&.\&.
.SH KEYWORDS
SO_REUSEPORT, TCP, TCP_FASTOPEN, configuration, connection thread pools, driver, module, nssock, nsssl, pagedir, performance, prebind, reverseproxy, tuning
