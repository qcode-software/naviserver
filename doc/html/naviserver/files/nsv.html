<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>nsv - NaviServer Built-in Commands</title>
<link rel="stylesheet" href="../man.css" type="text/css">
</head>
<!-- Generated from file 'nsv.man' by tcllib/doctools with format 'html'
   -->
<!-- nsv.n
   -->
<body><div id="man-header">
  <a href="https://wiki.tcl-lang.org/page/NaviServer"><span class="logo">&nbsp;</span><strong>NaviServer</strong></a>
  - programmable web server
</div>
 <hr> [
   <a href="../../toc.html">Main Table Of Contents</a>
&#124; <a href="../toc.html">Table Of Contents</a>
&#124; <a href="../../index.html">Keyword Index</a>
 ] <hr>
<div class="doctools">
<h1 class="doctools_title">nsv(n) 4.99.23 naviserver &quot;NaviServer Built-in Commands&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>nsv - NaviServer nsv Commands</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">COMMANDS</a></li>
<li class="doctools_section"><a href="#section3">Migrating From ns_share</a></li>
<li class="doctools_section"><a href="#section4">Multithreading Features</a></li>
<li class="doctools_section"><a href="#section5">Compatibility with Tcl Arrays</a></li>
<li class="doctools_section"><a href="#section6">Configuration</a>
<ul>
<li class="doctools_subsection"><a href="#subsection1">Number of buckets</a></li>
<li class="doctools_subsection"><a href="#subsection2">Mutex Locks vs. RWLocks</a></li>
</ul>
</li>
<li class="doctools_section"><a href="#see-also">See Also</a></li>
<li class="doctools_section"><a href="#keywords">Keywords</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_syntax">
<li><a href="#1"><b class="cmd">nsv_array get</b> <i class="arg">array</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></li>
<li><a href="#2"><b class="cmd">nsv_array set</b> <i class="arg">array</i> <i class="arg">value-list</i></a></li>
<li><a href="#3"><b class="cmd">nsv_array reset</b> <i class="arg">array</i> <i class="arg">value-list</i></a></li>
<li><a href="#4"><b class="cmd">nsv_array exists</b> <i class="arg">array</i></a></li>
<li><a href="#5"><b class="cmd">nsv_array size</b> <i class="arg">array</i></a></li>
<li><a href="#6"><b class="cmd">nsv_array names</b> <i class="arg">array</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></li>
<li><a href="#7"><b class="cmd">nsv_bucket</b> <span class="opt">?<i class="arg">bucket-nr</i>?</span></a></li>
<li><a href="#8"><b class="cmd">nsv_dict append</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></li>
<li><a href="#9"><b class="cmd">nsv_dict exists</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></li>
<li><a href="#10"><b class="cmd">nsv_dict get</b> <span class="opt">?-varname <i class="arg">varname</i>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></li>
<li><a href="#11"><b class="cmd">nsv_dict getdef</b> <span class="opt">?-varname <i class="arg">varname</i>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span> <i class="arg">default</i></a></li>
<li><a href="#12"><b class="cmd">nsv_dict incr</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">increment</i>?</span></a></li>
<li><a href="#13"><b class="cmd">nsv_dict keys</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></li>
<li><a href="#14"><b class="cmd">nsv_dict lappend</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></li>
<li><a href="#15"><b class="cmd">nsv_dict set</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span> <i class="arg">value</i></a></li>
<li><a href="#16"><b class="cmd">nsv_dict size</b> <i class="arg">array</i> <i class="arg">key</i></a></li>
<li><a href="#17"><b class="cmd">nsv_dict unset</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></li>
<li><a href="#18"><b class="cmd">nsv_exists</b> <i class="arg">array</i> <i class="arg">key</i></a></li>
<li><a href="#19"><b class="cmd">nsv_get</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">varName</i>?</span></a></li>
<li><a href="#20"><b class="cmd">nsv_incr</b> <i class="arg">arrayName</i> <i class="arg">key</i> <span class="opt">?<i class="arg">increment</i>?</span></a></li>
<li><a href="#21"><b class="cmd">nsv_append</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></li>
<li><a href="#22"><b class="cmd">nsv_lappend</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></li>
<li><a href="#23"><b class="cmd">nsv_names</b> <span class="opt">?<i class="arg">pattern</i>?</span></a></li>
<li><a href="#24"><b class="cmd">nsv_set</b> <span class="opt">?<b class="option">-default</b>?</span> <span class="opt">?<b class="option">-reset</b>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">value</i>?</span></a></li>
<li><a href="#25"><b class="cmd">nsv_unset</b> <span class="opt">?<b class="option">-nocomplain</b>?</span> <span class="opt">?--?</span> <i class="arg">array</i> <span class="opt">?<i class="arg">key</i>?</span></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>The nsv commands provide a high performance data sharing mechanism.
This facility is much flexible alternative to the obsolete ns_share
command.  The model uses an array syntax and includes more features.
In addition, lock contention is managed in a much more scalable
way--something that is not possible with the obsolete ns_share
facility.</p>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">COMMANDS</a></h2>
<dl class="doctools_definitions">
<dt><a name="1"><b class="cmd">nsv_array get</b> <i class="arg">array</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></dt>
<dd></dd>
<dt><a name="2"><b class="cmd">nsv_array set</b> <i class="arg">array</i> <i class="arg">value-list</i></a></dt>
<dd></dd>
<dt><a name="3"><b class="cmd">nsv_array reset</b> <i class="arg">array</i> <i class="arg">value-list</i></a></dt>
<dd></dd>
<dt><a name="4"><b class="cmd">nsv_array exists</b> <i class="arg">array</i></a></dt>
<dd></dd>
<dt><a name="5"><b class="cmd">nsv_array size</b> <i class="arg">array</i></a></dt>
<dd></dd>
<dt><a name="6"><b class="cmd">nsv_array names</b> <i class="arg">array</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></dt>
<dd><p>Commands for the most part mirror the corresponding Tcl command for
ordinary variables.</p>
<pre class="doctools_example">
 % nsv_array set shared_array { key1 value1 key2 value2 }
 
 % nsv_array get shared_array
 key1 value1 key2 value2
 
 % nsv_array reset shared_array { key3 value3 }
 
 % nsv_array exists shared_array
 1
 
 % nsv_array size shared_array
 1
 
 % nsv_array names shared_array
 key3
 
 % nsv_array set shared_array [array get tmp_shared_array]
 % array set tmp_shared_array [nsv_array get shared_array]
 % nsv_array reset shared_array [array get tmp_shared_array]
</pre>
</dd>
<dt><a name="7"><b class="cmd">nsv_bucket</b> <span class="opt">?<i class="arg">bucket-nr</i>?</span></a></dt>
<dd><p>Return a list of all the array names with lock counts from the specified
bucket. If no bucket-nr is specified, return a list of all arrays from
all buckets.  This command is mainly for performance tuning. When e.g.
the number of locks for a certain bucket is high one can use this
command to determine the arrays with their usages from this bucket.</p>
<pre class="doctools_example">
 set buckets &quot;&quot;
 set count -1
 foreach b [nsv_bucket] {
    append buckets &quot;[incr count]: &quot; [lsort -integer -index 1 -decreasing $b] \n
 }
 ns_log notice $buckets
</pre>
</dd>
<dt><a name="8"><b class="cmd">nsv_dict append</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></dt>
<dd></dd>
<dt><a name="9"><b class="cmd">nsv_dict exists</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></dt>
<dd></dd>
<dt><a name="10"><b class="cmd">nsv_dict get</b> <span class="opt">?-varname <i class="arg">varname</i>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></dt>
<dd></dd>
<dt><a name="11"><b class="cmd">nsv_dict getdef</b> <span class="opt">?-varname <i class="arg">varname</i>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span> <i class="arg">default</i></a></dt>
<dd></dd>
<dt><a name="12"><b class="cmd">nsv_dict incr</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">increment</i>?</span></a></dt>
<dd></dd>
<dt><a name="13"><b class="cmd">nsv_dict keys</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">pattern</i>?</span></a></dt>
<dd></dd>
<dt><a name="14"><b class="cmd">nsv_dict lappend</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></dt>
<dd></dd>
<dt><a name="15"><b class="cmd">nsv_dict set</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span> <i class="arg">value</i></a></dt>
<dd></dd>
<dt><a name="16"><b class="cmd">nsv_dict size</b> <i class="arg">array</i> <i class="arg">key</i></a></dt>
<dd></dd>
<dt><a name="17"><b class="cmd">nsv_dict unset</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">dictkey</i> <span class="opt">?<i class="arg">dictkey ...</i>?</span></a></dt>
<dd><p>Implementation of the Tcl <i class="term">dict</i> command for shared variables.
The commands work similar as <b class="cmd">nsv_set</b> and <b class="cmd">nsv_get</b>,
except that the value of these commands are structure values in form
of dicts.</p>
<p>The main difference to plain Tcl is the option
<span class="opt">?-varname <i class="arg">varname</i>?</span>.
When this option is provided, the function returns 0 or 1 depending
on success and returns in the success case the value in the provided
variable. When the varname option is provided, the behavior is
similar to the optional last argument in <b class="cmd">nsv_get</b> or
<b class="cmd">ns_cache_get</b>
The option <span class="opt">?-varname <i class="arg">varname</i>?</span> has the adavantage
to test and get the value with a single locked command. This avoids
race conditions and reduces the number of locks for the application.</p>
<pre class="doctools_example">
 % nsv_dict set personnel 4711 name gustaf
 name gustaf
 
 % nsv_dict set personnel 4711 sex m
 name gustaf sex m
 
 % nsv_dict get personnel 4711 name
 gustaf
 
 % nsv_dict get personnel 4711
 name gustaf sex m
</pre>
</dd>
<dt><a name="18"><b class="cmd">nsv_exists</b> <i class="arg">array</i> <i class="arg">key</i></a></dt>
<dd><p>Test whether a key exists in the nsv array.</p>
<pre class="doctools_example">
 % nsv_exists shared_array key1
 1
 % nsv_exists shared_array key2
 0
</pre>
</dd>
<dt><a name="19"><b class="cmd">nsv_get</b> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">varName</i>?</span></a></dt>
<dd><p>Get the value for the key from the nsv array.  If the optional
<i class="arg">varName</i> is provided, the function returns on success 1 and on
failure 0. On success, it binds the variable <i class="arg">varName</i>. If the
variable name is not provided, it returns on success the value and
raises on failure an error (similar to <b class="cmd">ns_cache_get</b>).
With the optional variable name, this function allows an atomic 
check for existence followed by a get operation.</p>
<pre class="doctools_example">
 % nsv_get shared_array key1
 value1
</pre>
</dd>
<dt><a name="20"><b class="cmd">nsv_incr</b> <i class="arg">arrayName</i> <i class="arg">key</i> <span class="opt">?<i class="arg">increment</i>?</span></a></dt>
<dd><p>If increment is supplied then its value (which must be an integer) is added to the
value of the element key; otherwise 1 is added to the value of the element key.
Unlike the Tcl equivalent if key does not exists it is created. Returns the new value
of the element specified by key. Internally interlocked so it is thread safe, no mutex required.</p>
<pre class="doctools_example">
 % nsv_incr shared_array foo
 1
 % nsv_incr shared_array foo -1
 0
</pre>
</dd>
<dt><a name="21"><b class="cmd">nsv_append</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></dt>
<dd><p>Append all of the value arguments to the current value of variable key in the array.
If key doesn't exist, it is given a value equal to the concatenation of all the value arguments</p>
<pre class="doctools_example">
 % nsv_append shared_array key1 foo
 value1foo
</pre>
</dd>
<dt><a name="22"><b class="cmd">nsv_lappend</b> <i class="arg">array</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></dt>
<dd><p>Append all of the value arguments as list elements to variable key in the array.
If key doesn't exist, it is created as a list with elements given by the value arguments</p>
<pre class="doctools_example">
 % nsv_lappend shared_array key1 value2
 value1 value2
</pre>
</dd>
<dt><a name="23"><b class="cmd">nsv_names</b> <span class="opt">?<i class="arg">pattern</i>?</span></a></dt>
<dd><p>Return a list of all the nsvs in use, optionally only those matching pattern. If no
matching nsvs are in use returns the empty string.</p>
<pre class="doctools_example">
 % nsv_names
 shared_array
</pre>
</dd>
<dt><a name="24"><b class="cmd">nsv_set</b> <span class="opt">?<b class="option">-default</b>?</span> <span class="opt">?<b class="option">-reset</b>?</span> <i class="arg">array</i> <i class="arg">key</i> <span class="opt">?<i class="arg">value</i>?</span></a></dt>
<dd><p>Set the value for a key in an nsv array. Returns the value the key is
set to. The various options are especially useful to implement atomic
operations.</p>
<dl class="doctools_options">
<dt><b class="option">-default</b></dt>
<dd><p>When this flag is specified nothing is changed in case
the key <i class="arg">key</i> of <i class="arg">array</i> has already an
value. Otherwise it sets the value.
This operation is similar to SETNX in REDIS (set if no exists).</p></dd>
<dt><b class="option">-reset</b></dt>
<dd><p>When this flag is specified and a <i class="arg">value</i> is given, the command
resets the value for <i class="arg">key</i> and returns the <em>old</em> value.
This operation is similar to GETSET in REDIS (get the old value and
set it new).</p>
<p>When this flag is specified but no <i class="arg">value</i> is
provided, the command returns the value for <i class="arg">key</i> and unsets resets it.</p></dd>
</dl>
<pre class="doctools_example">
 % nsv_set shared_array key1 value1
 value1
</pre>
</dd>
<dt><a name="25"><b class="cmd">nsv_unset</b> <span class="opt">?<b class="option">-nocomplain</b>?</span> <span class="opt">?--?</span> <i class="arg">array</i> <span class="opt">?<i class="arg">key</i>?</span></a></dt>
<dd><p>Unset an array or a single key from an array. If successful returns an
empty string. When <b class="option">-nocomplain</b> is specified the command does not
complain when the specified array or key does not exist.</p>
<pre class="doctools_example">
 % nsv_unset shared_array key1
 % nsv_unset shared_array
</pre>
</dd>
</dl>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">Migrating From ns_share</a></h2>
<p>Migrating from ns_share is straightforward.  If your init.tcl included commands such as:</p>
<pre class="doctools_example">
 ns_share myshare
 set myshare(lock) [ns_mutex create]
</pre>
<p>use instead:</p>
<pre class="doctools_example">
 nsv_set myshare lock [ns_mutex create]
</pre>
<p>In your procedures, instead of:</p>
<pre class="doctools_example">
 proc myproc {} {
     ns_share myshare
     ns_mutex lock $myshare(lock)
     ...
 }
</pre>
<p>use:</p>
<pre class="doctools_example">
 proc myproc {} {
     ns_mutex lock [nsv_get myshare lock]
     ...
 }
</pre>
<p>and within an ADP page, instead of:</p>
<pre class="doctools_example">
 &lt;%
  ns_share myshare
  ns_puts $myshare(key1)
 %&gt;
 
 &lt;%=$myshare(key2)%&gt;
</pre>
<p>use:</p>
<pre class="doctools_example">
 &lt;%
 ns_puts [nsv_get myshare key1]
 %&gt;
 
 &lt;%=[nsv_get myshare key2]%&gt;
</pre>
<p>Notice that, unlike ns_share, no command is required to define the
shared array.  The first attempt at setting the variable through any
means will automatically create the array.  Also notice that only arrays
are supported.  However, to migrate from ns_share you can simply package
up all existing ns_share scalars into a single array with a short name,
perhaps just &quot;.&quot;. For example, if you had:</p>
<pre class="doctools_example">
 ns_share mylock myfile
 set myfile /tmp/some.file
 set mylock [ns_mutex create]
</pre>
<p>you can use:</p>
<pre class="doctools_example">
 nsv_set . myfile /tmp/some.file
 nsv_set . mylock [ns_mutex create]
</pre>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">Multithreading Features</a></h2>
<p>One advantages of nsv is built in interlocking for thread safety.
For example, consider a case of a &quot;increment-by-one&quot; unique id system.
Here's the ns_share solution:</p>
<pre class="doctools_example">
 ns_share ids
 set ids(lock) [ns_mutex create]
 set ids(next) 0
 
 proc nextid {} {
     ns_share ids
     ns_mutex lock $ids(lock)
     set next [incr ids(next)]
     ns_mutex unlock $ids(lock)
     return $next
 }
</pre>
<p>and here's an nsv solution:</p>
<pre class="doctools_example">
 nsv_set ids next 0
 
 proc nextid {} {
     return [nsv_incr ids next]
 }
</pre>
<p>Note that the nsv solution does not need a mutex as the nsv_incr command
is internally interlocked.</p>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">Compatibility with Tcl Arrays</a></h2>
<p>Another useful feature of nsv is the nsv_array command which works much
like the Tcl array command.  This can be used to import and export values
from ordinary Tcl arrays.  For example, to copy from Tcl use:</p>
<pre class="doctools_example">
 nsv_array set meta [array get tmpmeta]
</pre>
<p>and to copy to Tcl use:</p>
<pre class="doctools_example">
 array set metacopy [nsv_array get meta]
</pre>
<p>As with all other nsv command, nsv_array is atomic and no explicit
locking is required.  This feature can be used to construct a new nsv
array by first filling up an ordinary temporary Tcl array via some time
consuming process and then swapping it into place as above.  While the
new temporary array is being constructed, other threads can access the
old array without delay or inconsistent data.  You can even reset a
complete nsv array in one step with &quot;reset&quot;.  For example, instead of:</p>
<pre class="doctools_example">
 ns_share lock meta
 set lock [ns_mutex create]
 ns_mutex lock $lock
 unset meta
 array set meta [array get tmpmeta]
 ns_mutex unlock $lock
</pre>
<p>you can simply use:</p>
<pre class="doctools_example">
 nsv_array reset meta [array get tmpmeta]
</pre>
<p>The reset option will flush and then reset all values atomically,
eliminating the need for the explicit lock.</p>
</div>
<div id="section6" class="doctools_section"><h2><a name="section6">Configuration</a></h2>
<p>All accesses to shared variables are protected by a mutex. Attention
should be taken for array operations which have to iterate over
many shared variables to return the result, since this will lead
to reduced scalability due too long lasting locks.</p>
<div id="subsection1" class="doctools_subsection"><h3><a name="subsection1">Number of buckets</a></h3>
<p>The nsv system uses a common multithreading technique to reduce the
potential for lock contention which is to split the locks to achieve
finer grained locking.  This technique groups arrays randomly into
buckets and only the arrays within a particular bucket share a lock.
The number of buckets to be used can be configured by setting the
<b class="const">nsvbuckets</b> Tcl parameters, e.g.:</p>
<pre class="doctools_example">
 ns_section  ns/server/${server}/tcl {
   # Number of buckets in Tcl hash table for nsv vars
   ns_param nsvbuckets 16
 }
</pre>
<p>The default value for <i class="term">nsvbuckets</i> is 8 which should be
reasonable for most applications.  Note that you can monitor the lock
contention by viewing the results of &quot;ns_info locks&quot; command after the
server has been running for some time.  The nsv locks all have names
of the form &quot;nsv:##&quot;.  If you find many lock attempts which did not
succeeded immediately, try increasing <i class="term">nsvbuckets</i>.</p>
</div>
<div id="subsection2" class="doctools_subsection"><h3><a name="subsection2">Mutex Locks vs. RWLocks</a></h3>
<p>An RWLock allows concurrent read access and a single writer, while a
mutex locks allows only a single reader or a single writer at the same
time. The RWLock has more overhead to support concurrency, but in case
there are more read than write operations, RWLocks are better (but
this might be different by the support for RWLocks). In general, for
Web server applications (like e.g. OpenACS), most nsv variables have a
write ratio of way below 1%. However, applications might be different,
so NaviServer allows the specify in the configuration file, whether
mutex locks or rwlocks might be used.</p>
<pre class="doctools_example">
 ns_section  ns/server/${server}/tcl {
   ns_param nsvrwlocks false   ;# default true
 }
</pre>
</div>
</div>
<div id="see-also" class="doctools_section"><h2><a name="see-also">See Also</a></h2>
<p><a href="ns_cache.html">ns_cache</a>, <a href="ns_set.html">ns_set</a>, <a href="ns_urlspace.html">ns_urlspace</a>, <a href="../../index.html#nsd">nsd</a></p>
</div>
<div id="keywords" class="doctools_section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../../index.html#configuration">configuration</a>, <a href="../../index.html#data_structure">data structure</a>, <a href="../../index.html#mutex">mutex</a>, <a href="../../index.html#nsv">nsv</a>, <a href="../../index.html#server_built_in">server built-in</a>, <a href="../../index.html#shared">shared</a>, <a href="../../index.html#variables">variables</a></p>
</div>
<div id="man-footer">
  
</div>
</div></body></html>
