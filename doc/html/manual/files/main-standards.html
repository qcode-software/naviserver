
<!DOCTYPE html><html><head>
<title>main-standards - NaviServer Manual</title>
<link rel="stylesheet" href="../man.css" type="text/css">
</head>
<!-- Generated from file 'main-standards.man' by tcllib/doctools with format 'html'
   -->
<!-- main-standards.n
   -->
<body><div id="man-header">
  <a href="http://wiki.tcl.tk/2090"><span class="logo">&nbsp;</span><strong>NaviServer</strong></a>
  - programmable web server
</div>
 <hr> [
   <a href="../../toc.html">Main Table Of Contents</a>
| <a href="../toc.html">Table Of Contents</a>
| <a href="../../index.html">Keyword Index</a>
 ] <hr>
<div class="doctools">
<h1 class="doctools_title">main-standards(n) 4.99.19 manual &quot;NaviServer Manual&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>main-standards - Engineering Standards Manual</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">Introduction</a></li>
<li class="doctools_section"><a href="#section3">Overall Structure</a></li>
<li class="doctools_section"><a href="#section4">Makefile Structure</a></li>
<li class="doctools_section"><a href="#section5">Header file structure</a></li>
<li class="doctools_section"><a href="#section6">Code File Structure</a></li>
<li class="doctools_section"><a href="#section7">Function definitions</a></li>
<li class="doctools_section"><a href="#section8">Parameter order</a></li>
<li class="doctools_section"><a href="#section9">Naming Conventions</a></li>
<li class="doctools_section"><a href="#section10">Basic Syntax Rules</a></li>
<li class="doctools_section"><a href="#section11">Function names contain meaning</a></li>
<li class="doctools_section"><a href="#section12">Low-level coding conventions</a></li>
<li class="doctools_section"><a href="#section13">Idioms, Canonical Forms, and Recommended Practices</a></li>
</ul>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>Contributed by George Nachman.</p>
<p>Based on the Tcl/Tk Engineering Manual by John K. Ousterhout</p>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">Introduction</a></h2>
<p>This manual is based on the <em>Tcl/Tk Engineering Manual</em> by John
K. Ousterhout that is available at <a href="http://www.activestate.com/">ActiveState</a>.
Most of this document is a subset of what his manual specifies, with the goal of
being more practical and up-to-date than the original. For example, it is assumed
that only an ANSI compiler will be used, whereas the Ousterhout's manual
describes conventions that will also work with non-ANSI compilers. The
<em>Tcl/Tk Engineering Manual</em> is still recommended reading,
particularly with respect to the section on code documentation, which
is not reproduced here.</p>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">Overall Structure</a></h2>
<p>Each module will be named ns<em>xxx</em>, where <em>xxx</em> is a short
name that describes the module. Each module will have its own
directory, and contain at least the following files:</p>
<ul class="doctools_itemized">
<li><p>ns<em>xxx</em>.c</p></li>
<li><p>Makefile</p></li>
</ul>
<p>If a module exports symbols, then a header file by the name of
ns<em>xxx</em>.h should also be in that directory.</p>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">Makefile Structure</a></h2>
<p>Use this as a template for module makefiles:</p>
<pre class="doctools_example">
#
# nsexample --
#
#      Example NaviServer module Makefile.
#
  
#
# NaviServer's location
#
#  Since your module probably doesn't live inside the &quot;naviserver&quot;
#  directory, you can tell make where to find NaviServer.
#
#NAVISERVER   =  /usr/local/ns
NAVISERVER    =  ../naviserver
 
#
# File name of binary loadable module
#
MOD           =  nsexample.so
 
#
# Object files for modules (required with MOD)
#
MODOBJS       =  nsexample.o
 
#     MODNAME     Unique name of module
#     TCL         List of module shared Tcl files
#     LIBNM       Root name of dynamic library (without lib prefix or extension)
#     LIBOBJS     List of library object files (required with LIBNM)
#     LIBHDRS     List of public header files to install (required with module LIBNM)
#     PGM         Name of executable program
#     PGMOBJS     List of program object files (required with PGM)
#     HDRS        Header files which objects depend on
#     MODLIBS     Extra module link libraries
#     LIBLIBS     Extra dynamic library link libraries
#     PGMLIBS     Extra program link libraries
#     INSTALL     Extra install directive(s)
#     CLEAN       Extra clean directive(s)
#     DESTDIR     Root directory for install
#
#     At least one of PGM, MOD, or LIBNM must be defined.  For backwards compatibility,
#     MODOBJS will default to OBJS and MODINST can be used for module install.
include  $(NSHOME)/include/Makefile.module
</pre>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">Header file structure</a></h2>
<p>Use this as a template for all header files:</p>
<pre class="doctools_example">
/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://mozilla.org.
 *
 * Software distributed under the License is distributed on an &quot;AS IS&quot;
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * Alternatively, the contents of this file may be used under the terms
 * of the GNU General Public License (the &quot;GPL&quot;), in which case the
 * provisions of GPL are applicable instead of those above.  If you wish
 * to allow use of your version of this file only under the terms of the
 * GPL and not to allow others to use your version of this file under the
 * License, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the GPL.
 * If you do not delete the provisions above, a recipient may use your
 * version of this file under either the License or the GPL.
 */
 
/*
 * file.h --
 *
 * 	Description of file.
 *
 */
 
#ifndef FILE_H
#define FILE_H
 
 
/*
 * The following constants...
 */
 
#define ...
 
/*
 * The following structure defines...
 */
 
typedef struct ...
 
/*
 * Exported functions
 */
 
extern ...
 
#endif /* FILE_H */
 
</pre>
<p>Header files never contain static symbols.</p>
</div>
<div id="section6" class="doctools_section"><h2><a name="section6">Code File Structure</a></h2>
<p>Each source code file should contain a related set of procedures. The
most manageable size for files is usually in the range of 500-2000
lines. Closely related functions should be placed as close together as
possible.</p>
<p>API functions (ns_*) come first; exported functions that are not API
calls (Ns*) come after those; static functions come last. Logical
groups of functions can be separated like this:</p>
<pre class="doctools_example">
/*
 *==========================================================================
 * This is where we torque the wingnut on the widget.
 *==========================================================================
 */
</pre>
<p>Use this as a template for all code files:</p>
<pre class="doctools_example">
/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://mozilla.org/.
 *
 * Software distributed under the License is distributed on an &quot;AS IS&quot;
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * Alternatively, the contents of this file may be used under the terms
 * of the GNU General Public License (the &quot;GPL&quot;), in which case the
 * provisions of GPL are applicable instead of those above.  If you wish
 * to allow use of your version of this file only under the terms of the
 * GPL and not to allow others to use your version of this file under the
 * License, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the GPL.
 * If you do not delete the provisions above, a recipient may use your
 * version of this file under either the License or the GPL.
 */
 
/*
 * file.c --
 *
 * 	Description of file.
 */
 
#include &quot;file.h&quot;
 
/*
 * The following constants...
 */
 
#define ...
 
/*
 * The following structure defines...
 */
 
typedef struct ...
 
/*
 * Local functions defined in this file
 */
 
static int FunctionName(int x);
 
/*
 * Static variables defined in this file
 */
 
static int nsNumFooBar;     /* Number of foobars allocated */
...
 
/*
 *==========================================================================
 * API functions
 *==========================================================================
 */
 
 (API function definitions go here)
 
/*
 *==========================================================================
 * Exported functions
 *==========================================================================
 */
 
 (Exported, non-api functions go here)
 
/*
 *==========================================================================
 * Static functions
 *==========================================================================
 */
 
(Static functions go here)
 
</pre>
<p>Source files should never contain extern statements; those belong in
header files (called file.h in the above template).</p>
</div>
<div id="section7" class="doctools_section"><h2><a name="section7">Function definitions</a></h2>
<p>Function definitions should follow this template:</p>
<pre class="doctools_example">
   /*
    *----------------------------------------------------------------------
    * FunctionName --
    *
    * 	Description of function.
    *
    * Results:
    *	This function returns ...
    *
    * Side effects:
    *	A new thread will be created.
    *
    *----------------------------------------------------------------------
    */
    
   static int
   FunctionName(int x)
   {
	...
   }
</pre>
<p>All functions definitions begin on a new page (which is to say they
should be preceded by a control-L character). All functions must be
typed: use void if the function returns no result. The second line
gives the function's name and argument list. If there are many
arguments, they should spill onto additional lines as such:</p>
<pre class="doctools_example">
   static int
   FunctionThatTakesLotsOfParameters(int a, int b, int c, int d, int e,
                                     int f, int g)
   {
	...
   }
</pre>
<p>The same rule applies to prototypes.</p>
</div>
<div id="section8" class="doctools_section"><h2><a name="section8">Parameter order</a></h2>
<p>Function parameters may be divided into three categories. <em>In</em>
parameters only pass information into the function (either directly or
by pointing to information that the function reads). <em>Out</em>
parameters point to things in the caller's memory that the function
modifies. <em>In-out</em> parameters do both. Below is a set of rules
for deciding on the order of parameters to a function:</p>
<ol class="doctools_enumerated">
<li><p>Parameters should normally appear in the order in, in/out, out,
except where overridden by the rules below.</p></li>
<li><p>If there is a group of functions, all of which operate on
structures of a particular type--such as a hash table--the token for
the structure should be the first argument to each of the functions.</p></li>
<li><p>When two parameters are the address of a callback function and a
context value (or ClientData value) to pass to that function, the
function address should appear in the argument list immediately before
the context/ClientData.</p></li>
<li><p>If a callback function takes a context/ClientData argument (and
all callbacks should), the context/ClientData argument should be the
first argument to the procedure. Typically the context/ClientData is a
pointer to the structure managed by the callback, so this is really
the same as rule 2.</p></li>
<li><p>In/out parameters should not be used without a <em>very </em>good
reason.</p></li>
</ol>
</div>
<div id="section9" class="doctools_section"><h2><a name="section9">Naming Conventions</a></h2>
<ol class="doctools_enumerated">
<li><p>Be consistent. Use the same name to refer to the same thing
everywhere. For example, in the Tcl implementation the name
<em>interp</em> is used consistently for pointers to the user-visible
Tcl_Interp structure.</p></li>
<li><p>Make sure a function name describes what the function actually
does. Will the name make sense out of context?</p></li>
<li><p>Sometimes it is appropriate to use one-letter variables, such as a
for-loop control variable called <em>i</em>. For anything more complex,
a short descriptive name should be used.</p></li>
</ol>
</div>
<div id="section10" class="doctools_section"><h2><a name="section10">Basic Syntax Rules</a></h2>
<ol class="doctools_enumerated">
<li><p>Variable names always start with a lowercase letter. Function and
type names always start with an uppercase letter.</p></li>
<li><p>In multi-word names, the first letter of each word after the first
is in uppercase (usually referred to as camel case). Example:</p>
<pre class="doctools_example">
   int nsThreadTimeout;
</pre>
</li>
<li><p>Any name that refers to a pointer ends in Ptr. If it is a pointer
to a pointer, then it ends in PtrPtr. Exceptions to this rule include
opaque handles for structures (such as ns_ModLogHandle) and char *
variables that refer to null-terminated strings. Also, static buffers
should not have the Ptr suffix, as in this case:</p>
<pre class="doctools_example">
   char buf[32];
</pre>
<p>It is recommended that the names of variables of type Tcl_Objs end
with Obj.</p></li>
<li><p>Variables that hold address of procedures should have names ending
in Proc, as should typedefs for such variables.</p>
<pre class="doctools_example">
   typedef int (Ns_ModuleInitProc) (const char *server, const char *module);
</pre>
</li>
<li><p><em>#define</em> macros and constants should be in all
uppercase. Underscores separate multiple words (as in NS_TRUE).</p></li>
<li><p>Tcl commands are always in all-lowercase.</p></li>
</ol>
</div>
<div id="section11" class="doctools_section"><h2><a name="section11">Function names contain meaning</a></h2>
<p>Public exported functions that are part of the API should begin with
Ns_, as in:</p>
<pre class="doctools_example">
   extern int Ns_ConnPort(const Ns_Conn *conn)
</pre>
<p>Functions that are to be used by other files in a module, but are
not meant to be called from outside the module, should begin with Ns,
as in:</p>
<pre class="doctools_example">
   extern void NsDbInit(void);
</pre>
<p>Global variables that do <em>not</em> have static scope begin with ns, as in:</p>
<pre class="doctools_example">
   ns_Cache *nsAdpCachePtr = NULL;
</pre>
<p>C implementations of Tcl commands should be ending with Cmd, as in:</p>
<pre class="doctools_example">
   int NsTclSetObjCmd(ClientData arg, Tcl_Interp *interp, int objc, Tcl_Obj *CONST* objv);
</pre>
</div>
<div id="section12" class="doctools_section"><h2><a name="section12">Low-level coding conventions</a></h2>
<p>If you use Emacs, the following lisp (which you can put in your
.emacs file) will make C-mode do much of the formatting for you (its
default behavior is almost correct--this just makes indents be four
spaces):</p>
<pre class="doctools_example">
   (add-hook 'c-mode-hook
   	(function (lambda ()
   		(setq c-basic-offset 4)
   		(setq c-indent-level 4))))
</pre>
<p>Try to follow these rules:</p>
<ul class="doctools_itemized">
<li><p>Indents are four spaces</p></li>
<li><p>Code comments occupy full lines, with empty lines before and
after, as such:</p>
<pre class="doctools_example">
   foo();
    
   /*
    * This is a comment.
    */
    
   bar();
</pre>
</li>
<li><p>Opening curly braces go at the end of a line, except for the
beginnings of functions, as such:</p>
<pre class="doctools_example">
   if (x == y) {
       FooBar();
   }
</pre>
<p>and</p>
<pre class="doctools_example">
   static void
   FooBar(void)
   {
      Foo();
   }
</pre>
</li>
<li><p>Always put a blank line after variable definitions:</p>
<pre class="doctools_example">
   static void
   FooBar(void)
   {
       int blah;
    
       ...
       if (blah != 0) {
           char *string;
    
   	   ...
       }
   }
</pre>
</li>
<li><p>Use curly braces even if you don't have to, such as in if
statements that have only statement in the block. There is an
exception to this, which is else if clauses which may look like
this:</p>
<pre class="doctools_example">
   if (!strcmp(cmd, &quot;put&quot;)) {
       ...
   } else if (!strcmp(cmd, &quot;get&quot;)) {
       ...
   } else if (!strcmp(cmd, &quot;reset&quot;)) {
       ...
   } else {
       ...
   }
</pre>
</li>
<li><p>No line should exceed 79 characters.</p></li>
<li><p>Labels are indented four spaces fewer than statements, except when
they would touch the left margin, in which case they are indented one
space in from the left margin.</p></li>
<li><p>Switch statements should look like this:</p>
<pre class="doctools_example">
   switch (adPtr-&gt;exception) {
   case ADP_OK:
       exception = &quot;ok&quot;;
       break;
       
   case ADP_BREAK:
       exception = &quot;break&quot;;
       break;
   ...
   }
</pre>
</li>
<li><p>Avoid macros except for extremely simple operations. Enclose
arguments in parentheses, as well as the entire macro
expression:</p>
<pre class="doctools_example">
   #define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))
</pre>
</li>
<li><p>Do not use bit fields</p></li>
<li><p>Goto statements may be used as long as they jump to the end of a
function that then performs cleanup and returns. They are an excellent
way of ensuring that functions have only one exit point. Most other
uses of goto are, as usual, looked on with disdain.</p></li>
<li><p>Common sense applies when using obscure or confusing parts of the
C language. For example, don't do this:</p>
<pre class="doctools_example">
    if (++c != NULL) {
       foo();
   }
</pre>
</li>
<li><p>Where it is sensible, have only one return statement in each function.</p></li>
<li><p>Complex if statements (such as those with three or more expressions)
should have newline breaks after the operator separating each expression.
In this case, put a newline after the open brace to separate the
conditions from the code that follows.</p>
<pre class="doctools_example">
    if (foo == bar &amp;&amp;
        baz == spoo &amp;&amp;
       ns_FooBarBaz() == NS_TRUE) {
    
       ...
   }
</pre>
</li>
<li><p>When there are multiple variables defined in a block, the first letter
of each variable name should line up, with asterisks running to the left.
There should not be multiple variables defined on the same line unless the
relationship between them is obvious. Non-obvious variables may be
commented to the right.</p>
<p>The leftmost asterisk should begin on the column that is one space
after the rightmost character of the longest type name. If there are no
pointers, then every variable name should begin on the column that is one space
after the rightmost character of the longest type name.</p>
<pre class="doctools_example">
    void
    Foo(void)
   {
       int              bar;
       unsigned int    *fooPtr;
       int          ****extremePtrPtrPtrPtr;  /* Just an example! */
    
       ...
</pre>
<p>or</p>
<pre class="doctools_example">
    void
    Foo(void)
   {
       int          bar;
       unsigned int foo;
       char         baz;
    
       ...
</pre>
<p>Variable initializers should not be anything more complex than a constant;
function calls and complicated expressions deserve their own lines of code.</p></li>
<li><p>In pointer definitions, be they local variables,
global variables, parameters, or static functions prototypes,
the asterisk should always make
contact with the first character of the symbol. In typecasts, there should
be one space between the type name and the asterisk, and parentheses should
make contact with both:</p>
<pre class="doctools_example">
    static void *Foo(int *fooPtr);
    int *fooPtr = (int *) barPtr;
</pre>
</li>
<li><p>If a function ends with a return statement which is neither the only
statement in the function body and is not preceded by a label, an empty
line should appear before it:</p>
<pre class="doctools_example">
static int
    Foo(void)
   {
       ...
       FooBar();
    
       return code;
   }
</pre>
</li>
</ul>
</div>
<div id="section13" class="doctools_section"><h2><a name="section13">Idioms, Canonical Forms, and Recommended Practices</a></h2>
<p>The following conventions are frequently used in NaviServer. They
are the recommended way of implementing a behavior.</p>
<ul class="doctools_itemized">
<li><p>Configuration parameters should be defined at the top of source files, as
such:</p>
<pre class="doctools_example">
   #define CONFIG_CACHE &quot;Cache&quot;     /* Enable caching in this module? */
   #define CONFIG_FOO   &quot;Foo&quot;       /* What is foo? */
 
   #define DEFAULT_CACHE NS_TRUE    /* Caching is on */
   #define DEFAULT_FOO   &quot;Bar&quot;      /* Foo is bar */
</pre>
</li>
<li><p>C is not PL/I. Write this:</p>
<pre class="doctools_example">
    return foo;
</pre>
<p>not</p>
<pre class="doctools_example">
    return (foo);
</pre>
<p>With very complicated expressions, parentheses are acceptable:</p>
<pre class="doctools_example">
    return (sqrt(variance) + foo() / bar() - (MAGIC + getch()) % 99);
</pre>
</li>
<li><p>Booleans can only have two values: <b class="const">NS_TRUE</b> and <b class="const">NS_FALSE</b>.
Using 0 and 1 as boolean values is discouraged. Also avoid using the
conventions of</p>
<pre class="doctools_example">
    if (foo) { ... }
</pre>
<p>and</p>
<pre class="doctools_example">
    if (!foo) { ... }
</pre>
<p>rather, say:</p>
<pre class="doctools_example">
    if (foo == NS_TRUE) {
       ...
   }
</pre>
<p>or</p>
<pre class="doctools_example">
    if (foo == NS_FALSE) {
       ...
   }
</pre>
<p>Of course, this only applies to NaviServer APIs and internal boolean values.
Respect the wishes of library calls; values from outside code should never
be compared with <b class="const">NS_TRUE</b> or <b class="const">NS_FALSE</b>, nor should
<b class="const">NS_TRUE</b> or <b class="const">NS_FALSE</b> values
ever be passed to outside code.</p></li>
<li><p>Explicit checks for null values are usually preferred over implicit checks.</p>
<p>For pointers, use <b class="const">NULL</b>:</p>
<pre class="doctools_example">
   if (fooPtr == NULL) {
       ...
   }
</pre>
<p>or</p>
<pre class="doctools_example">
   if (fooPtr != NULL) {
       ...
   }
</pre>
<p>For characters, use <b class="const">'\0'</b> when checking for equality to zero:</p>
<pre class="doctools_example">
    if (char == '\0') {
       ...
   }
</pre>
<p>For integers, explicitly use <b class="const">0</b> when checking for equality to zero:</p>
<pre class="doctools_example">
    if (foo == 0) {
       ...
   }
</pre>
</li>
</ul>
</div>
<div id="man-footer">
  
</div>
</div></body></html>
