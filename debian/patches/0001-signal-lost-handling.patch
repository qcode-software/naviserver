From: David Osborne <david@qcode.co.uk>
Date: Mon, 13 Apr 2015 15:24:39 +0100
Subject: signal lost handling

---
 nsd/queue.c |   39 +++++++++++++++++++++++++++++----------
 1 file changed, 29 insertions(+), 10 deletions(-)

diff --git a/nsd/queue.c b/nsd/queue.c
index 37b6fb2..2560557 100644
--- a/nsd/queue.c
+++ b/nsd/queue.c
@@ -1164,19 +1164,38 @@ NsConnThread(void *arg)
 		
 		if (status == NS_TIMEOUT) {
 		    if (argPtr->connPtr != NULL) {
-			/* this should not happen; probably a signal was lost */
+			/* 
+                         * This should not happen: we had a timeout, but there
+                         * is a connection to be handled; when a connection
+                         * comes in, we get signaled and should see therefore
+                         * no timeout.  Maybe the signal was lost?
+                         */
 			Ns_Log(Warning, "signal lost, resuming after timeout");
 			status = NS_OK;
-		    }
-		    if (poolPtr->threads.current <= poolPtr->threads.min) {continue;}
-		    /* 
-		     * We have a timeout, and the thread can exit 
-		     */
-		    break;
+
+		    } else if (poolPtr->threads.current <= poolPtr->threads.min) {
+                        /* 
+                         * We have a timeout, but we should not reduce the
+                         * number of threads below min-threads.
+                         */
+                        continue;
+                        
+                    } else {
+                        /* 
+                         * We have a timeout, and the thread can exit 
+                         */
+                        break;
+                    }
 		}
-		if (argPtr->connPtr != NULL) {break;}
-		
-		Ns_Log(Debug, "CondTimedWait returned an unexpected result, maybe shutdown?");
+
+		if (argPtr->connPtr != NULL) {
+                    /*
+                     * We got something to do
+                     */
+                    break;
+                }
+
+                Ns_Log(Debug, "Unexpected condition after CondTimedWait; maybe shutdown?");
 	    }
 
 	    Ns_MutexUnlock(&argPtr->lock);
